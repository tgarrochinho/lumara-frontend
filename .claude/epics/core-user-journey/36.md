---
name: Memory Actions (Edit/Delete)
status: open
created: 2025-10-14T21:12:26Z
updated: 2025-10-14T21:25:10Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/36
depends_on: [32]
parallel: true
conflicts_with: [33]
---

# Task 36: Memory Actions (Edit/Delete)

## Description

Add edit and delete functionality to memory cards, allowing users to modify or remove memories. This task implements a dropdown action menu on each card with inline editing support, delete confirmation, and optimistic UI updates for smooth user experience.

**Key focus:** Proper UX patterns (confirmation dialogs, optimistic updates, error recovery) and embedding regeneration when content changes.

## Acceptance Criteria

- [ ] Each memory card has an actions dropdown menu (three-dot icon)
- [ ] Dropdown contains "Edit" and "Delete" options
- [ ] Edit mode switches card to inline editing (textarea + Save/Cancel buttons)
- [ ] Changes persist to Dexie database on Save
- [ ] Editing content triggers embedding regeneration
- [ ] Delete shows confirmation dialog before removing
- [ ] Optimistic updates: UI updates immediately, reverts on error
- [ ] Error messages display if operation fails
- [ ] Loading states show during async operations
- [ ] Keyboard shortcuts: Enter to save, Escape to cancel
- [ ] Edited timestamp updates to show "last updated"
- [ ] Actions menu closes when clicking outside (focus trap)

## Technical Details

### Component: MemoryActions

**Dropdown Menu:**
```typescript
// src/components/memories/MemoryActions.tsx
import { useState } from 'react';
import { useMemoryActions } from '@/hooks/useMemoryActions';
import DeleteConfirmation from './DeleteConfirmation';

interface MemoryActionsProps {
  memoryId: number;
  onEdit: () => void;
}

export default function MemoryActions({ memoryId, onEdit }: MemoryActionsProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const { deleteMemory, isDeleting } = useMemoryActions();

  const handleDelete = async () => {
    await deleteMemory(memoryId);
    setShowDeleteConfirm(false);
  };

  return (
    <>
      {/* Three-dot menu button */}
      <div className="memory-actions">
        <button
          onClick={() => setIsOpen(!isOpen)}
          aria-label="Memory actions"
          aria-expanded={isOpen}
          aria-haspopup="true"
        >
          <DotsIcon />
        </button>

        {/* Dropdown menu */}
        {isOpen && (
          <div
            className="actions-dropdown"
            role="menu"
            onBlur={() => setIsOpen(false)}
          >
            <button
              role="menuitem"
              onClick={() => {
                onEdit();
                setIsOpen(false);
              }}
            >
              Edit
            </button>
            <button
              role="menuitem"
              onClick={() => {
                setShowDeleteConfirm(true);
                setIsOpen(false);
              }}
              className="text-red-600"
            >
              Delete
            </button>
          </div>
        )}
      </div>

      {/* Delete confirmation dialog */}
      {showDeleteConfirm && (
        <DeleteConfirmation
          onConfirm={handleDelete}
          onCancel={() => setShowDeleteConfirm(false)}
          isDeleting={isDeleting}
        />
      )}
    </>
  );
}
```

### Updated: MemoryCard with Edit Mode

**Add inline editing:**
```typescript
// src/components/memories/MemoryCard.tsx (updated)
import { useState } from 'react';
import { Memory } from '@/lib/db';
import { useMemoryActions } from '@/hooks/useMemoryActions';
import MemoryActions from './MemoryActions';

interface MemoryCardProps {
  memory: Memory;
  similarity?: number;
}

export default function MemoryCard({ memory, similarity }: MemoryCardProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editedContent, setEditedContent] = useState(memory.content);
  const { updateMemory, isUpdating, error } = useMemoryActions();

  const handleSave = async () => {
    if (editedContent.trim() === memory.content) {
      setIsEditing(false);
      return;
    }

    const success = await updateMemory(memory.id!, {
      content: editedContent.trim(),
    });

    if (success) {
      setIsEditing(false);
    }
  };

  const handleCancel = () => {
    setEditedContent(memory.content);
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      handleCancel();
    }
    // Save on Cmd/Ctrl + Enter
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      handleSave();
    }
  };

  if (isEditing) {
    return (
      <article className="memory-card editing">
        <textarea
          value={editedContent}
          onChange={(e) => setEditedContent(e.target.value)}
          onKeyDown={handleKeyDown}
          autoFocus
          aria-label="Edit memory content"
        />

        {error && (
          <div className="error-message" role="alert">
            {error}
          </div>
        )}

        <div className="edit-actions">
          <button
            onClick={handleSave}
            disabled={isUpdating}
            aria-busy={isUpdating}
          >
            {isUpdating ? 'Saving...' : 'Save'}
          </button>
          <button onClick={handleCancel} disabled={isUpdating}>
            Cancel
          </button>
        </div>
      </article>
    );
  }

  return (
    <article className="memory-card">
      <header>
        <span className={`badge badge-${memory.type}`}>{memory.type}</span>
        <time dateTime={memory.updatedAt.toISOString()}>
          {formatRelativeTime(memory.updatedAt)}
        </time>
        <MemoryActions
          memoryId={memory.id!}
          onEdit={() => setIsEditing(true)}
        />
      </header>

      <div className="content">
        <p>{memory.content}</p>
      </div>

      {similarity && (
        <div className="similarity-score">
          {Math.round(similarity * 100)}% match
        </div>
      )}

      {memory.tags && memory.tags.length > 0 && (
        <footer>
          {memory.tags.map(tag => (
            <span key={tag} className="tag">#{tag}</span>
          ))}
        </footer>
      )}
    </article>
  );
}
```

### Custom Hook: useMemoryActions

**CRUD operations with optimistic updates:**
```typescript
// src/hooks/useMemoryActions.ts
import { useState } from 'react';
import { db, Memory } from '@/lib/db';
import { generateEmbedding } from '@/lib/ai/embeddings/transformers';

export function useMemoryActions() {
  const [isUpdating, setIsUpdating] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const updateMemory = async (
    id: number,
    updates: Partial<Omit<Memory, 'id' | 'createdAt' | 'updatedAt'>>
  ): Promise<boolean> => {
    setIsUpdating(true);
    setError(null);

    try {
      // Get current memory for rollback
      const current = await db.memories.get(id);
      if (!current) {
        throw new Error('Memory not found');
      }

      // Optimistic update
      await db.memories.update(id, {
        ...updates,
        updatedAt: new Date(),
      });

      // Regenerate embedding if content changed
      if (updates.content && updates.content !== current.content) {
        const embedding = await generateEmbedding(updates.content);
        await db.memories.update(id, { embedding });
      }

      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update memory');
      // Note: Dexie live query will automatically revert UI on error
      return false;
    } finally {
      setIsUpdating(false);
    }
  };

  const deleteMemory = async (id: number): Promise<boolean> => {
    setIsDeleting(true);
    setError(null);

    try {
      // Get current memory for rollback
      const current = await db.memories.get(id);
      if (!current) {
        throw new Error('Memory not found');
      }

      // Optimistic delete
      await db.memories.delete(id);

      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete memory');
      // Note: Could restore from current if needed
      return false;
    } finally {
      setIsDeleting(false);
    }
  };

  return {
    updateMemory,
    deleteMemory,
    isUpdating,
    isDeleting,
    error,
  };
}
```

### Component: DeleteConfirmation

**Modal dialog:**
```typescript
// src/components/memories/DeleteConfirmation.tsx
interface DeleteConfirmationProps {
  onConfirm: () => void;
  onCancel: () => void;
  isDeleting: boolean;
}

export default function DeleteConfirmation({
  onConfirm,
  onCancel,
  isDeleting,
}: DeleteConfirmationProps) {
  return (
    <div className="modal-overlay" onClick={onCancel}>
      <div
        className="modal-content"
        onClick={(e) => e.stopPropagation()}
        role="alertdialog"
        aria-labelledby="delete-title"
        aria-describedby="delete-description"
      >
        <h2 id="delete-title">Delete Memory?</h2>
        <p id="delete-description">
          This action cannot be undone. The memory will be permanently removed.
        </p>

        <div className="modal-actions">
          <button onClick={onCancel} disabled={isDeleting}>
            Cancel
          </button>
          <button
            onClick={onConfirm}
            disabled={isDeleting}
            className="btn-danger"
            aria-busy={isDeleting}
          >
            {isDeleting ? 'Deleting...' : 'Delete'}
          </button>
        </div>
      </div>
    </div>
  );
}
```

### Files to Create/Modify

- **Create:** `src/hooks/useMemoryActions.ts` (~100 lines)
- **Create:** `src/components/memories/MemoryActions.tsx` (~80 lines)
- **Create:** `src/components/memories/DeleteConfirmation.tsx` (~60 lines)
- **Modify:** `src/components/memories/MemoryCard.tsx` (add edit mode + actions menu)
- **Create:** `src/lib/utils/icons.tsx` (DotsIcon component)

### Testing Strategy

**Unit Tests:**
```typescript
describe('useMemoryActions', () => {
  it('updates memory and regenerates embedding', async () => {
    const { result } = renderHook(() => useMemoryActions());

    // Create test memory
    const id = await db.memories.add({
      content: 'Original content',
      type: 'knowledge',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    // Update content
    await act(async () => {
      await result.current.updateMemory(id, {
        content: 'Updated content',
      });
    });

    // Verify update
    const updated = await db.memories.get(id);
    expect(updated?.content).toBe('Updated content');
    expect(updated?.embedding).toBeDefined(); // New embedding generated
  });

  it('handles update errors gracefully', async () => {
    // Test error recovery
  });

  it('deletes memory successfully', async () => {
    // Test delete operation
  });
});

describe('MemoryCard', () => {
  it('enters edit mode when Edit clicked', async () => {
    const memory = { /* test data */ };
    render(<MemoryCard memory={memory} />);

    // Open actions menu
    await userEvent.click(screen.getByLabelText(/memory actions/i));

    // Click Edit
    await userEvent.click(screen.getByRole('menuitem', { name: /edit/i }));

    // Verify edit mode
    expect(screen.getByLabelText(/edit memory content/i)).toBeInTheDocument();
  });

  it('saves changes on Save button click', async () => {
    // Test save operation
  });

  it('cancels edit on Escape key', async () => {
    // Test keyboard shortcut
  });
});

describe('DeleteConfirmation', () => {
  it('calls onConfirm when Delete clicked', async () => {
    const onConfirm = vi.fn();
    render(<DeleteConfirmation onConfirm={onConfirm} onCancel={vi.fn()} isDeleting={false} />);

    await userEvent.click(screen.getByRole('button', { name: /delete/i }));
    expect(onConfirm).toHaveBeenCalled();
  });
});
```

**Integration Test:**
```typescript
describe('Memory Edit/Delete Flow', () => {
  it('edits memory end-to-end', async () => {
    // Create memory
    const id = await db.memories.add({ /* test data */ });

    render(<App />);

    // Open actions menu
    const card = screen.getByTestId(`memory-card-${id}`);
    const actionsBtn = within(card).getByLabelText(/memory actions/i);
    await userEvent.click(actionsBtn);

    // Click Edit
    await userEvent.click(screen.getByRole('menuitem', { name: /edit/i }));

    // Edit content
    const textarea = screen.getByLabelText(/edit memory content/i);
    await userEvent.clear(textarea);
    await userEvent.type(textarea, 'Updated content');

    // Save
    await userEvent.click(screen.getByRole('button', { name: /save/i }));

    // Verify update
    await waitFor(() => {
      expect(screen.getByText('Updated content')).toBeInTheDocument();
    });

    const updated = await db.memories.get(id);
    expect(updated?.content).toBe('Updated content');
  });

  it('deletes memory with confirmation', async () => {
    // Test delete flow
  });
});
```

## Dependencies

**Depends on:**
- [32] Memory List & Cards - Requires `MemoryCard` component to add actions to

**Existing Infrastructure (Wave 0.2):**
- `src/lib/ai/embeddings/transformers.ts` - For regenerating embeddings
- `src/lib/db.ts` - Dexie database operations

**Blocks:**
- None - other tasks can proceed independently

**Can run parallel with:**
- [34] Search & Filters - Independent feature
- [31] Contradiction Detection UI - Independent feature

**Conflicts with:**
- [33] Layout & Polish - Both modify `MemoryCard.tsx`; task 33 should come last

## Effort Estimate

**Total:** 0.5 days (4 hours)

**Breakdown:**
- `useMemoryActions` hook: 1 hour
- `MemoryActions` dropdown menu: 1 hour
- `DeleteConfirmation` modal: 0.5 hours
- Update `MemoryCard` with edit mode: 1 hour
- Unit tests: 0.5 hours

**Risk buffer:** Low - straightforward CRUD operations with well-defined patterns

## Definition of Done

- [ ] Actions dropdown menu works on each card
- [ ] Edit mode allows inline editing
- [ ] Save regenerates embedding if content changed
- [ ] Delete shows confirmation dialog
- [ ] Optimistic updates work correctly
- [ ] Error messages display on failure
- [ ] Keyboard shortcuts work (Enter to save, Escape to cancel)
- [ ] Unit tests written and passing (>90% coverage)
- [ ] Integration test verifies edit and delete flows
- [ ] Accessibility: Keyboard navigation works, ARIA labels correct
- [ ] Code reviewed and merged to main branch
- [ ] No TypeScript errors
- [ ] No ESLint warnings
- [ ] Manual testing: Can edit and delete memories, UI updates immediately, errors handled gracefully

---

**Related:** Epic [core-user-journey](./epic.md) | Previous: [34-search-filters.md](./34.md) | Next: [31-contradiction-detection.md](./31.md)

---
name: Search & Filters
status: open
created: 2025-10-14T21:12:26Z
updated: 2025-10-14T21:12:26Z
github: null
depends_on: [001, 004]
parallel: false
conflicts_with: []
---

# Task 005: Search & Filters

## Description

Implement semantic search and type filtering for memories, leveraging the existing embedding system from Wave 0.2. This task adds a search bar and filter UI to the MemoryList component, enabling users to find memories through natural language queries (semantic search) or filter by memory type (knowledge/experience/method).

**Key insight:** All infrastructure already exists - we're just wiring up the UI to call `findSimilar()` from `src/lib/ai/utils/similarity.ts`.

## Acceptance Criteria

- [ ] Search bar accepts natural language queries (e.g., "react hooks")
- [ ] Semantic search uses existing embeddings + cosine similarity
- [ ] Search results display relevance scores (0-100%)
- [ ] Type filters (All, Knowledge, Experience, Method) work independently of search
- [ ] Filters and search can be combined (e.g., search "react" + filter "knowledge")
- [ ] Search is debounced (300ms) to avoid excessive computation
- [ ] Results update in real-time as user types
- [ ] Clear button resets search + filters to show all memories
- [ ] Loading indicator shows during embedding generation (if needed)
- [ ] Empty search results show helpful message ("No memories found for 'query'")
- [ ] Search query persists in URL query params (shareable links)
- [ ] Keyboard shortcuts: Cmd+K/Ctrl+K to focus search, Escape to clear

## Technical Details

### Custom Hook: useMemorySearch

**Primary implementation:**
```typescript
// src/hooks/useMemorySearch.ts
import { useState, useEffect, useMemo } from 'react';
import { useLiveQuery } from 'dexie-react-hooks';
import { db, Memory, MemoryType } from '@/lib/db';
import { generateEmbedding } from '@/lib/ai/embeddings/transformers';
import { findSimilar } from '@/lib/ai/utils/similarity';
import { useDebounce } from '@/hooks/useDebounce';

export interface UseMemorySearchOptions {
  searchQuery: string;
  filterType: MemoryType | 'all';
  threshold?: number; // Default: 0.7
}

export interface SearchResult extends Memory {
  similarity?: number; // Relevance score (0-1) for semantic search
}

export function useMemorySearch({
  searchQuery,
  filterType,
  threshold = 0.7,
}: UseMemorySearchOptions) {
  const [isSearching, setIsSearching] = useState(false);
  const debouncedQuery = useDebounce(searchQuery, 300);

  // Get all memories with Dexie live query
  const allMemories = useLiveQuery(
    () => db.memories.orderBy('createdAt').reverse().toArray()
  );

  // Apply filters and search
  const results = useMemo(async () => {
    if (!allMemories) return [];

    setIsSearching(true);
    try {
      let filtered = allMemories;

      // 1. Apply type filter first (cheap operation)
      if (filterType !== 'all') {
        filtered = filtered.filter(m => m.type === filterType);
      }

      // 2. Apply semantic search if query exists
      if (debouncedQuery.trim().length > 0) {
        // Generate embedding for search query
        const queryEmbedding = await generateEmbedding(debouncedQuery);

        // Find similar memories using existing similarity.ts
        const matches = await findSimilar(
          queryEmbedding,
          filtered,
          { threshold, limit: 50 }
        );

        // Return with similarity scores
        return matches.map(match => ({
          ...filtered.find(m => m.id === match.id)!,
          similarity: match.similarity,
        }));
      }

      // No search query - return filtered list
      return filtered;
    } finally {
      setIsSearching(false);
    }
  }, [allMemories, debouncedQuery, filterType, threshold]);

  return { results, isSearching };
}
```

### Component: MemoryFilters

**UI Component:**
```typescript
// src/components/memories/MemoryFilters.tsx
import { MemoryType } from '@/lib/db';

interface MemoryFiltersProps {
  searchQuery: string;
  filterType: MemoryType | 'all';
  onSearchChange: (query: string) => void;
  onFilterChange: (type: MemoryType | 'all') => void;
  resultCount: number;
}

export default function MemoryFilters({
  searchQuery,
  filterType,
  onSearchChange,
  onFilterChange,
  resultCount,
}: MemoryFiltersProps) {
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      onSearchChange('');
      onFilterChange('all');
    }
  };

  useEffect(() => {
    // Global keyboard shortcut: Cmd/Ctrl + K
    const handleGlobalShortcut = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        document.getElementById('memory-search')?.focus();
      }
    };

    window.addEventListener('keydown', handleGlobalShortcut);
    return () => window.removeEventListener('keydown', handleGlobalShortcut);
  }, []);

  return (
    <div className="memory-filters">
      {/* Search bar */}
      <div className="search-bar">
        <input
          id="memory-search"
          type="search"
          placeholder="Search memories... (Cmd+K)"
          value={searchQuery}
          onChange={(e) => onSearchChange(e.target.value)}
          onKeyDown={handleKeyDown}
          aria-label="Search memories"
        />
        {searchQuery && (
          <button
            onClick={() => onSearchChange('')}
            aria-label="Clear search"
          >
            Clear
          </button>
        )}
      </div>

      {/* Type filters */}
      <div className="type-filters" role="tablist">
        {['all', 'knowledge', 'experience', 'method'].map(type => (
          <button
            key={type}
            role="tab"
            aria-selected={filterType === type}
            className={filterType === type ? 'active' : ''}
            onClick={() => onFilterChange(type as MemoryType | 'all')}
          >
            {type.charAt(0).toUpperCase() + type.slice(1)}
          </button>
        ))}
      </div>

      {/* Result count */}
      <div className="result-count">
        {resultCount} {resultCount === 1 ? 'memory' : 'memories'}
      </div>
    </div>
  );
}
```

### Modified: MemoryList Integration

**Update MemoryList.tsx:**
```typescript
// src/components/memories/MemoryList.tsx
import { useState } from 'react';
import { useMemorySearch } from '@/hooks/useMemorySearch';
import MemoryFilters from './MemoryFilters';
import MemoryCard from './MemoryCard';
import EmptyState from '../layout/EmptyState';

export default function MemoryList() {
  const [searchQuery, setSearchQuery] = useState('');
  const [filterType, setFilterType] = useState<'all' | MemoryType>('all');

  const { results, isSearching } = useMemorySearch({
    searchQuery,
    filterType,
  });

  return (
    <div className="memory-list-container">
      <MemoryFilters
        searchQuery={searchQuery}
        filterType={filterType}
        onSearchChange={setSearchQuery}
        onFilterChange={setFilterType}
        resultCount={results?.length ?? 0}
      />

      {isSearching && <div>Searching...</div>}

      {!isSearching && results?.length === 0 && (
        searchQuery ? (
          <div>No memories found for "{searchQuery}"</div>
        ) : (
          <EmptyState />
        )
      )}

      {!isSearching && results?.length > 0 && (
        <div className="memory-grid">
          {results.map(memory => (
            <MemoryCard
              key={memory.id}
              memory={memory}
              similarity={memory.similarity}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

### URL Query Params Integration

```typescript
// src/hooks/useSearchParams.ts
import { useSearchParams } from 'react-router-dom';

export function useMemorySearchParams() {
  const [params, setParams] = useSearchParams();

  const searchQuery = params.get('q') ?? '';
  const filterType = (params.get('type') ?? 'all') as MemoryType | 'all';

  const updateSearch = (query: string) => {
    if (query) {
      params.set('q', query);
    } else {
      params.delete('q');
    }
    setParams(params);
  };

  const updateFilter = (type: MemoryType | 'all') => {
    if (type !== 'all') {
      params.set('type', type);
    } else {
      params.delete('type');
    }
    setParams(params);
  };

  return { searchQuery, filterType, updateSearch, updateFilter };
}
```

### Files to Create/Modify

- **Create:** `src/hooks/useMemorySearch.ts` (~120 lines)
- **Create:** `src/hooks/useDebounce.ts` (~20 lines, utility hook)
- **Create:** `src/hooks/useSearchParams.ts` (~40 lines)
- **Create:** `src/components/memories/MemoryFilters.tsx` (~100 lines)
- **Modify:** `src/components/memories/MemoryList.tsx` (integrate filters)
- **Modify:** `src/components/memories/MemoryCard.tsx` (show similarity score if present)

### Testing Strategy

**Unit Tests:**
```typescript
describe('useMemorySearch', () => {
  it('returns all memories when no filters applied', async () => {
    // Test baseline
  });

  it('filters by type correctly', async () => {
    const { result } = renderHook(() => useMemorySearch({
      searchQuery: '',
      filterType: 'knowledge',
    }));
    // Verify only knowledge memories returned
  });

  it('performs semantic search with embeddings', async () => {
    const { result } = renderHook(() => useMemorySearch({
      searchQuery: 'react hooks',
      filterType: 'all',
    }));
    // Verify similar memories ranked by cosine similarity
  });

  it('combines search and filters', async () => {
    // Search "react" + filter "knowledge"
  });

  it('debounces search queries', async () => {
    // Verify embedding generation only called after 300ms
  });
});

describe('MemoryFilters', () => {
  it('calls onSearchChange when typing', () => {
    // Test input handling
  });

  it('clears search on Escape key', () => {
    // Test keyboard shortcut
  });

  it('focuses search on Cmd+K', () => {
    // Test global shortcut
  });
});
```

**Integration Test:**
```typescript
describe('Search & Filter Integration', () => {
  it('searches and filters memories end-to-end', async () => {
    // Create test memories
    await db.memories.bulkAdd([
      { content: 'React hooks tutorial', type: 'knowledge', ... },
      { content: 'Used useState in project', type: 'experience', ... },
      { content: 'Remember to useEffect dependencies', type: 'method', ... },
    ]);

    render(<App />);

    // Type search query
    await userEvent.type(screen.getByPlaceholderText(/search/i), 'react');

    // Wait for debounce + search
    await waitFor(() => {
      expect(screen.getAllByTestId('memory-card')).toHaveLength(3);
    });

    // Apply filter
    await userEvent.click(screen.getByRole('tab', { name: /knowledge/i }));

    // Verify combined results
    await waitFor(() => {
      expect(screen.getAllByTestId('memory-card')).toHaveLength(1);
      expect(screen.getByText(/react hooks tutorial/i)).toBeInTheDocument();
    });
  });
});
```

## Dependencies

**Depends on:**
- [001] Database Operations & Hooks - Requires `db.memories` and live queries
- [004] Memory List & Cards - Requires `MemoryList` container to integrate into

**Existing Infrastructure (Wave 0.2):**
- `src/lib/ai/embeddings/transformers.ts` - `generateEmbedding()` function
- `src/lib/ai/utils/similarity.ts` - `findSimilar()` function
- All embeddings already generated for existing memories

**Blocks:**
- None - other tasks can proceed independently

**Can run parallel with:**
- [006] Memory Actions - Independent feature
- [007] Contradiction Detection UI - Independent feature

## Effort Estimate

**Total:** 1 day (8 hours)

**Breakdown:**
- `useMemorySearch` hook implementation: 2.5 hours
- `MemoryFilters` component: 2 hours
- URL query params integration: 1 hour
- Unit tests: 1.5 hours
- Integration testing + polish: 1 hour

**Risk buffer:** Medium - Embedding generation might be slow on first search (mitigated by caching)

## Definition of Done

- [ ] Search bar accepts queries and displays results
- [ ] Semantic search using embeddings works correctly
- [ ] Type filters work independently and combined with search
- [ ] Search is debounced (verified with timing tests)
- [ ] Keyboard shortcuts work (Cmd+K, Escape)
- [ ] URL query params persist search state
- [ ] Loading states display during search
- [ ] Empty results show helpful message
- [ ] Unit tests written and passing (>90% coverage)
- [ ] Integration test verifies end-to-end flow
- [ ] Performance: Search completes in <200ms for 100 memories
- [ ] Code reviewed and merged to main branch
- [ ] No TypeScript errors
- [ ] No ESLint warnings
- [ ] Manual testing: Can search and filter, results are relevant, UI is responsive

---

**Related:** Epic [core-user-journey](./epic.md) | Previous: [004-memory-list.md](./004.md) | Next: [006-memory-actions.md](./006.md)

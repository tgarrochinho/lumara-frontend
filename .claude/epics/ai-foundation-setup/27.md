---
name: Similarity Detection & Contradiction Logic
status: open
created: 2025-10-14T03:28:21Z
updated: 2025-10-14T03:44:38Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/27
depends_on: [26]
parallel: false
conflicts_with: []
---

# Task: Similarity Detection & Contradiction Logic

## Description
Implement cosine similarity calculations and semantic analysis logic to detect when memories contradict or duplicate each other. Build the core algorithms that enable Lumara's unique contradiction detection feature.

## Acceptance Criteria
- [ ] Cosine similarity function returns accurate scores (0-1 range)
- [ ] findSimilar() efficiently searches through 1000+ memories in <50ms
- [ ] Threshold-based detection: duplication (>0.85), contradiction (>0.70)
- [ ] Batch similarity computation for performance
- [ ] Unit tests validate similarity scores with known test cases
- [ ] Performance benchmarks met

## Technical Details

### Files to Create
```
src/lib/ai/utils/
├── similarity.ts            # Cosine similarity and search
├── contradiction.ts         # Contradiction detection logic
└── vector-math.ts           # Vector operations
```

### Implementation

1. **Vector Math Utilities** (`src/lib/ai/utils/vector-math.ts`)
```typescript
export function dotProduct(a: number[], b: number[]): number {
  if (a.length !== b.length) {
    throw new Error('Vectors must have same length');
  }
  return a.reduce((sum, val, i) => sum + val * b[i], 0);
}

export function magnitude(vector: number[]): number {
  return Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
}

export function normalize(vector: number[]): number[] {
  const mag = magnitude(vector);
  return vector.map(val => val / mag);
}
```

2. **Cosine Similarity** (`src/lib/ai/utils/similarity.ts`)
```typescript
import { dotProduct, magnitude } from './vector-math';

export function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length) {
    throw new Error(`Vector dimension mismatch: ${a.length} vs ${b.length}`);
  }

  const dot = dotProduct(a, b);
  const magA = magnitude(a);
  const magB = magnitude(b);

  if (magA === 0 || magB === 0) {
    return 0;
  }

  return dot / (magA * magB);
}

export interface SimilarityMatch {
  id: string;
  similarity: number;
  content: string;
}

export interface SimilaritySearchOptions {
  threshold?: number;
  limit?: number;
  excludeIds?: string[];
}

export async function findSimilar(
  queryEmbedding: number[],
  memories: Array<{ id: string; content: string; embedding?: number[] }>,
  options: SimilaritySearchOptions = {}
): Promise<SimilarityMatch[]> {
  const {
    threshold = 0.7,
    limit = 10,
    excludeIds = [],
  } = options;

  const similarities: SimilarityMatch[] = [];

  for (const memory of memories) {
    // Skip if excluded
    if (excludeIds.includes(memory.id)) continue;

    // Skip if no embedding
    if (!memory.embedding) continue;

    // Calculate similarity
    const similarity = cosineSimilarity(queryEmbedding, memory.embedding);

    // Add if above threshold
    if (similarity >= threshold) {
      similarities.push({
        id: memory.id,
        similarity,
        content: memory.content,
      });
    }
  }

  // Sort by similarity (descending)
  similarities.sort((a, b) => b.similarity - a.similarity);

  // Limit results
  return similarities.slice(0, limit);
}

export function batchCosineSimilarity(
  query: number[],
  vectors: number[][]
): number[] {
  return vectors.map(vector => cosineSimilarity(query, vector));
}
```

3. **Contradiction Detection** (`src/lib/ai/utils/contradiction.ts`)
```typescript
import { findSimilar, SimilarityMatch } from './similarity';
import { AIProvider } from '../types';

export interface ContradictionResult {
  contradicts: boolean;
  confidence: number;
  explanation: string;
  memory1Id: string;
  memory2Id: string;
}

export interface ContradictionCandidate {
  memory: SimilarityMatch;
  semanticallySimilar: boolean;
}

export async function detectContradictions(
  newMemoryId: string,
  newMemoryContent: string,
  newMemoryEmbedding: number[],
  existingMemories: Array<{ id: string; content: string; embedding: number[] }>,
  aiProvider: AIProvider
): Promise<ContradictionResult[]> {
  // Step 1: Find semantically similar memories (>0.70 similarity)
  const similar = await findSimilar(
    newMemoryEmbedding,
    existingMemories,
    { threshold: 0.70, excludeIds: [newMemoryId] }
  );

  if (similar.length === 0) {
    return [];
  }

  // Step 2: Use AI to analyze each similar memory for contradiction
  const contradictions: ContradictionResult[] = [];

  for (const match of similar) {
    const analysis = await analyzeContradiction(
      newMemoryContent,
      match.content,
      aiProvider
    );

    if (analysis.contradicts) {
      contradictions.push({
        ...analysis,
        memory1Id: newMemoryId,
        memory2Id: match.id,
      });
    }
  }

  return contradictions;
}

async function analyzeContradiction(
  text1: string,
  text2: string,
  aiProvider: AIProvider
): Promise<Omit<ContradictionResult, 'memory1Id' | 'memory2Id'>> {
  const prompt = `
Analyze if these two statements contradict each other:

Statement 1: "${text1}"
Statement 2: "${text2}"

Respond in JSON format:
{
  "contradicts": true/false,
  "confidence": 0-100,
  "explanation": "brief explanation of why they do or don't contradict"
}

Consider:
- Direct contradictions (X is true vs X is false)
- Contextual contradictions (may be true in different contexts)
- Complementary statements (both can be true)
`;

  try {
    const response = await aiProvider.chat(prompt);

    // Try to parse JSON from response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const result = JSON.parse(jsonMatch[0]);
      return {
        contradicts: result.contradicts === true,
        confidence: Math.min(100, Math.max(0, result.confidence || 0)),
        explanation: result.explanation || 'No explanation provided',
      };
    }
  } catch (error) {
    console.error('Error analyzing contradiction:', error);
  }

  // Fallback if AI analysis fails
  return {
    contradicts: false,
    confidence: 0,
    explanation: 'Could not analyze for contradiction',
  };
}

export async function detectDuplicates(
  newMemoryEmbedding: number[],
  existingMemories: Array<{ id: string; content: string; embedding: number[] }>,
  threshold = 0.85
): Promise<SimilarityMatch[]> {
  return findSimilar(newMemoryEmbedding, existingMemories, { threshold });
}
```

### Testing Strategy
```typescript
describe('Similarity Detection', () => {
  it('calculates cosine similarity correctly', () => {
    const a = [1, 0, 0];
    const b = [1, 0, 0];
    expect(cosineSimilarity(a, b)).toBeCloseTo(1.0);

    const c = [1, 0, 0];
    const d = [0, 1, 0];
    expect(cosineSimilarity(c, d)).toBeCloseTo(0.0);
  });

  it('finds similar memories above threshold', async () => {
    const queryEmbedding = [/* ... */];
    const memories = [/* ... */];
    const similar = await findSimilar(queryEmbedding, memories, {
      threshold: 0.7,
    });
    expect(similar.every(m => m.similarity >= 0.7)).toBe(true);
  });

  it('detects duplicates with high similarity', async () => {
    // Test duplicate detection
  });
});
```

## Dependencies
- [ ] Task 002 (Embeddings) must be complete
- [ ] AI Provider (Task 001) for contradiction analysis

## Effort Estimate
- **Size:** S (Small)
- **Hours:** 8-10 hours
- **Parallel:** No - Depends on Task 002

## Definition of Done
- [ ] Cosine similarity function accurate
- [ ] findSimilar() performs <50ms for 1000 memories
- [ ] Contradiction detection logic implemented
- [ ] Duplicate detection working
- [ ] Unit tests with >90% coverage
- [ ] Performance benchmarks validated
- [ ] Code reviewed and documented

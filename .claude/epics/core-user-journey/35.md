---
name: Database Operations & Hooks
status: open
created: 2025-10-14T21:12:26Z
updated: 2025-10-14T21:25:10Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/35
depends_on: []
parallel: true
conflicts_with: []
---

# Task 35: Database Operations & Hooks

## Description

Create the foundational data layer for memory management by implementing Dexie CRUD operations and React hooks. This task builds directly on Wave 0.2's existing database schema and embedding infrastructure, wrapping them in ergonomic hooks for React components.

**What to Build:**
- Dexie operations wrapper (`memories.ts`) for all memory CRUD operations
- `useMemories` hook for reactive memory list with live queries
- `useConversation` hook for managing chat state and AI interactions
- Comprehensive unit tests ensuring data integrity

**Key Insight:** The Memory schema, Dexie setup, and embedding generation already exist from Wave 0.2. This task is about creating the interface layer between existing infrastructure and new UI components.

## Acceptance Criteria

- [ ] `src/lib/db/memories.ts` exports all CRUD functions with proper TypeScript types
- [ ] `createMemory()` generates embeddings automatically using existing `generateEmbedding()`
- [ ] `updateMemory()` regenerates embeddings when content changes
- [ ] `deleteMemory()` removes memory and associated data
- [ ] `searchMemories()` uses semantic search with existing similarity functions
- [ ] `filterMemories()` returns memories by type (knowledge/experience/method/all)
- [ ] `useMemories` hook returns live-updating memory list via `useLiveQuery()`
- [ ] `useMemories` provides CRUD methods with optimistic updates
- [ ] `useConversation` hook manages message array and typing state
- [ ] `useConversation` integrates with existing AI provider for chat
- [ ] All operations handle errors gracefully with proper error messages
- [ ] Unit tests achieve >90% coverage for all functions
- [ ] Tests verify Dexie live queries trigger re-renders correctly
- [ ] TypeScript compilation passes with no errors

## Technical Details

### Files to Create

**1. Database Operations Wrapper**
```typescript
// src/lib/db/memories.ts
import { db } from './database';
import { generateEmbedding } from '../ai/embeddings';
import { calculateSimilarity } from '../ai/utils/similarity';
import type { Memory, MemoryType } from './schema';

/**
 * Create a new memory with automatic embedding generation
 * @param data - Memory data (excluding id and timestamps)
 * @returns Promise<number> - The ID of the created memory
 */
export async function createMemory(
  data: Omit<Memory, 'id' | 'created_at' | 'updated_at' | 'embedding'>
): Promise<number> {
  const embedding = await generateEmbedding(data.content);
  const now = new Date();

  const id = await db.memories.add({
    ...data,
    embedding,
    created_at: now,
    updated_at: now,
  });

  return id;
}

/**
 * Update an existing memory (regenerates embedding if content changed)
 * @param id - Memory ID
 * @param data - Partial memory data to update
 */
export async function updateMemory(
  id: number,
  data: Partial<Omit<Memory, 'id' | 'created_at'>>
): Promise<void> {
  const updates: Partial<Memory> = {
    ...data,
    updated_at: new Date(),
  };

  // Regenerate embedding if content changed
  if (data.content) {
    updates.embedding = await generateEmbedding(data.content);
  }

  await db.memories.update(id, updates);
}

/**
 * Delete a memory
 * @param id - Memory ID
 */
export async function deleteMemory(id: number): Promise<void> {
  await db.memories.delete(id);
}

/**
 * Get a single memory by ID
 * @param id - Memory ID
 * @returns Promise<Memory | undefined>
 */
export async function getMemory(id: number): Promise<Memory | undefined> {
  return db.memories.get(id);
}

/**
 * Get all memories (reverse chronological)
 * @returns Promise<Memory[]>
 */
export async function getAllMemories(): Promise<Memory[]> {
  return db.memories.orderBy('created_at').reverse().toArray();
}

/**
 * Filter memories by type
 * @param type - Memory type to filter by
 * @returns Promise<Memory[]>
 */
export async function filterMemories(type: MemoryType): Promise<Memory[]> {
  return db.memories
    .where('type')
    .equals(type)
    .reverse()
    .sortBy('created_at');
}

/**
 * Semantic search across all memories
 * @param query - Search query text
 * @param threshold - Similarity threshold (0.0-1.0), default 0.7
 * @param limit - Maximum results, default 20
 * @returns Promise<Array<Memory & { score: number }>>
 */
export async function searchMemories(
  query: string,
  threshold = 0.7,
  limit = 20
): Promise<Array<Memory & { score: number }>> {
  // Generate query embedding
  const queryEmbedding = await generateEmbedding(query);

  // Get all memories
  const allMemories = await db.memories.toArray();

  // Calculate similarities
  const results = allMemories
    .map(memory => ({
      ...memory,
      score: calculateSimilarity(queryEmbedding, memory.embedding),
    }))
    .filter(result => result.score >= threshold)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit);

  return results;
}

/**
 * Get memories count
 * @returns Promise<number>
 */
export async function getMemoriesCount(): Promise<number> {
  return db.memories.count();
}
```

**2. Memories Hook**
```typescript
// src/hooks/useMemories.ts
import { useLiveQuery } from 'dexie-react-hooks';
import { useCallback } from 'react';
import { db } from '../lib/db/database';
import {
  createMemory as dbCreateMemory,
  updateMemory as dbUpdateMemory,
  deleteMemory as dbDeleteMemory,
  searchMemories as dbSearchMemories,
  filterMemories as dbFilterMemories,
} from '../lib/db/memories';
import type { Memory, MemoryType } from '../lib/db/schema';

export interface UseMemoriesOptions {
  filter?: MemoryType;
  searchQuery?: string;
}

export interface UseMemoriesReturn {
  memories: Memory[] | undefined;
  isLoading: boolean;
  createMemory: (data: Omit<Memory, 'id' | 'created_at' | 'updated_at' | 'embedding'>) => Promise<number>;
  updateMemory: (id: number, data: Partial<Memory>) => Promise<void>;
  deleteMemory: (id: number) => Promise<void>;
  searchMemories: (query: string) => Promise<Array<Memory & { score: number }>>;
}

/**
 * React hook for memory CRUD operations with live updates
 *
 * Uses Dexie's useLiveQuery for reactive updates - any database
 * changes automatically trigger re-renders.
 *
 * @param options - Filter and search options
 * @returns Memory list and CRUD operations
 */
export function useMemories(options: UseMemoriesOptions = {}): UseMemoriesReturn {
  const { filter, searchQuery } = options;

  // Live query - automatically re-renders on DB changes
  const memories = useLiveQuery(async () => {
    if (searchQuery) {
      const results = await dbSearchMemories(searchQuery);
      return results;
    }

    if (filter && filter !== 'all') {
      return dbFilterMemories(filter);
    }

    return db.memories.orderBy('created_at').reverse().toArray();
  }, [filter, searchQuery]);

  const createMemory = useCallback(
    async (data: Omit<Memory, 'id' | 'created_at' | 'updated_at' | 'embedding'>) => {
      return dbCreateMemory(data);
    },
    []
  );

  const updateMemory = useCallback(
    async (id: number, data: Partial<Memory>) => {
      return dbUpdateMemory(id, data);
    },
    []
  );

  const deleteMemory = useCallback(
    async (id: number) => {
      return dbDeleteMemory(id);
    },
    []
  );

  const searchMemories = useCallback(
    async (query: string) => {
      return dbSearchMemories(query);
    },
    []
  );

  return {
    memories,
    isLoading: memories === undefined,
    createMemory,
    updateMemory,
    deleteMemory,
    searchMemories,
  };
}
```

**3. Conversation Hook**
```typescript
// src/hooks/useConversation.ts
import { useCallback, useState } from 'react';
import { aiRegistry } from '../lib/ai/registry';

export interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export interface UseConversationReturn {
  messages: Message[];
  isTyping: boolean;
  sendMessage: (content: string) => Promise<void>;
  clearMessages: () => void;
}

/**
 * React hook for managing conversation with AI
 *
 * Uses existing AI provider from registry (Chrome AI by default).
 * Maintains message history and typing state.
 *
 * @returns Conversation state and actions
 */
export function useConversation(): UseConversationReturn {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isTyping, setIsTyping] = useState(false);

  const sendMessage = useCallback(async (content: string) => {
    // Add user message
    const userMessage: Message = {
      id: `user-${Date.now()}`,
      role: 'user',
      content,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setIsTyping(true);

    try {
      // Get AI provider (Chrome AI preferred)
      const provider = aiRegistry.getProvider('chrome-ai') ??
                      aiRegistry.getBestProvider();

      if (!provider) {
        throw new Error('No AI provider available');
      }

      // Build context from recent messages (last 5)
      const context = messages
        .slice(-5)
        .map(m => `${m.role}: ${m.content}`);

      // Get AI response
      const response = await provider.chat(content, context);

      // Add assistant message
      const assistantMessage: Message = {
        id: `assistant-${Date.now()}`,
        role: 'assistant',
        content: response,
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Failed to send message:', error);

      // Add error message
      const errorMessage: Message = {
        id: `error-${Date.now()}`,
        role: 'assistant',
        content: 'Sorry, I encountered an error. Please try again.',
        timestamp: new Date(),
      };

      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsTyping(false);
    }
  }, [messages]);

  const clearMessages = useCallback(() => {
    setMessages([]);
  }, []);

  return {
    messages,
    isTyping,
    sendMessage,
    clearMessages,
  };
}
```

**4. Unit Tests**
```typescript
// src/lib/db/__tests__/memories.test.ts
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import {
  createMemory,
  updateMemory,
  deleteMemory,
  getMemory,
  getAllMemories,
  filterMemories,
  searchMemories,
  getMemoriesCount,
} from '../memories';
import { db } from '../database';

describe('Memory CRUD Operations', () => {
  beforeEach(async () => {
    await db.delete();
    await db.open();
  });

  afterEach(async () => {
    await db.close();
  });

  describe('createMemory', () => {
    it('creates memory with embedding', async () => {
      const id = await createMemory({
        content: 'React hooks run on render',
        type: 'knowledge',
        tags: ['react', 'hooks'],
      });

      const memory = await getMemory(id);
      expect(memory).toBeDefined();
      expect(memory!.content).toBe('React hooks run on render');
      expect(memory!.embedding).toHaveLength(384); // MiniLM-L6-v2 dimensions
      expect(memory!.created_at).toBeInstanceOf(Date);
    });

    it('sets timestamps automatically', async () => {
      const before = new Date();
      const id = await createMemory({
        content: 'Test content',
        type: 'knowledge',
        tags: [],
      });
      const after = new Date();

      const memory = await getMemory(id);
      expect(memory!.created_at.getTime()).toBeGreaterThanOrEqual(before.getTime());
      expect(memory!.created_at.getTime()).toBeLessThanOrEqual(after.getTime());
    });
  });

  describe('updateMemory', () => {
    it('updates memory fields', async () => {
      const id = await createMemory({
        content: 'Original',
        type: 'knowledge',
        tags: [],
      });

      await updateMemory(id, {
        content: 'Updated',
        tags: ['new-tag'],
      });

      const memory = await getMemory(id);
      expect(memory!.content).toBe('Updated');
      expect(memory!.tags).toContain('new-tag');
    });

    it('regenerates embedding when content changes', async () => {
      const id = await createMemory({
        content: 'Original',
        type: 'knowledge',
        tags: [],
      });

      const original = await getMemory(id);
      const originalEmbedding = original!.embedding;

      await updateMemory(id, { content: 'Completely different' });

      const updated = await getMemory(id);
      expect(updated!.embedding).not.toEqual(originalEmbedding);
    });

    it('updates updated_at timestamp', async () => {
      const id = await createMemory({
        content: 'Test',
        type: 'knowledge',
        tags: [],
      });

      const original = await getMemory(id);
      await new Promise(resolve => setTimeout(resolve, 10)); // Ensure time passes

      await updateMemory(id, { tags: ['updated'] });

      const updated = await getMemory(id);
      expect(updated!.updated_at.getTime()).toBeGreaterThan(
        original!.updated_at.getTime()
      );
    });
  });

  describe('deleteMemory', () => {
    it('removes memory from database', async () => {
      const id = await createMemory({
        content: 'To delete',
        type: 'knowledge',
        tags: [],
      });

      await deleteMemory(id);

      const memory = await getMemory(id);
      expect(memory).toBeUndefined();
    });
  });

  describe('filterMemories', () => {
    it('returns only memories of specified type', async () => {
      await createMemory({ content: 'K1', type: 'knowledge', tags: [] });
      await createMemory({ content: 'E1', type: 'experience', tags: [] });
      await createMemory({ content: 'K2', type: 'knowledge', tags: [] });

      const knowledge = await filterMemories('knowledge');
      expect(knowledge).toHaveLength(2);
      expect(knowledge.every(m => m.type === 'knowledge')).toBe(true);
    });
  });

  describe('searchMemories', () => {
    it('finds semantically similar memories', async () => {
      await createMemory({
        content: 'React is a JavaScript library for building UIs',
        type: 'knowledge',
        tags: [],
      });
      await createMemory({
        content: 'I ate pizza for lunch',
        type: 'experience',
        tags: [],
      });

      const results = await searchMemories('frontend frameworks');
      expect(results.length).toBeGreaterThan(0);
      expect(results[0].content).toContain('React');
      expect(results[0].score).toBeGreaterThan(0.7);
    });

    it('respects threshold parameter', async () => {
      await createMemory({
        content: 'Completely unrelated content',
        type: 'knowledge',
        tags: [],
      });

      const results = await searchMemories('React hooks', 0.9);
      expect(results).toHaveLength(0);
    });
  });
});

// src/hooks/__tests__/useMemories.test.tsx
import { describe, it, expect } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useMemories } from '../useMemories';
import { db } from '../../lib/db/database';

describe('useMemories hook', () => {
  it('returns empty array initially', async () => {
    const { result } = renderHook(() => useMemories());

    await waitFor(() => {
      expect(result.current.memories).toEqual([]);
    });
  });

  it('creates memory and updates list reactively', async () => {
    const { result } = renderHook(() => useMemories());

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    await result.current.createMemory({
      content: 'Test memory',
      type: 'knowledge',
      tags: [],
    });

    await waitFor(() => {
      expect(result.current.memories).toHaveLength(1);
      expect(result.current.memories![0].content).toBe('Test memory');
    });
  });

  it('filters memories by type', async () => {
    const { result: allResult } = renderHook(() => useMemories());

    await allResult.current.createMemory({
      content: 'Knowledge',
      type: 'knowledge',
      tags: [],
    });
    await allResult.current.createMemory({
      content: 'Experience',
      type: 'experience',
      tags: [],
    });

    const { result: filteredResult } = renderHook(() =>
      useMemories({ filter: 'knowledge' })
    );

    await waitFor(() => {
      expect(filteredResult.current.memories).toHaveLength(1);
      expect(filteredResult.current.memories![0].type).toBe('knowledge');
    });
  });
});

// src/hooks/__tests__/useConversation.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { renderHook, waitFor } from '@testing-library/react';
import { useConversation } from '../useConversation';
import { aiRegistry } from '../../lib/ai/registry';

describe('useConversation hook', () => {
  it('starts with empty messages', () => {
    const { result } = renderHook(() => useConversation());

    expect(result.current.messages).toEqual([]);
    expect(result.current.isTyping).toBe(false);
  });

  it('sends message to AI and receives response', async () => {
    const mockProvider = {
      chat: vi.fn().mockResolvedValue('AI response'),
    };
    vi.spyOn(aiRegistry, 'getProvider').mockReturnValue(mockProvider as any);

    const { result } = renderHook(() => useConversation());

    await result.current.sendMessage('Hello AI');

    await waitFor(() => {
      expect(result.current.messages).toHaveLength(2);
      expect(result.current.messages[0].role).toBe('user');
      expect(result.current.messages[0].content).toBe('Hello AI');
      expect(result.current.messages[1].role).toBe('assistant');
      expect(result.current.messages[1].content).toBe('AI response');
    });
  });

  it('handles errors gracefully', async () => {
    const mockProvider = {
      chat: vi.fn().mockRejectedValue(new Error('API error')),
    };
    vi.spyOn(aiRegistry, 'getProvider').mockReturnValue(mockProvider as any);

    const { result } = renderHook(() => useConversation());

    await result.current.sendMessage('Hello');

    await waitFor(() => {
      expect(result.current.messages).toHaveLength(2);
      expect(result.current.messages[1].content).toContain('error');
    });
  });
});
```

### Integration Points

**Existing Code to Use:**
- `/Users/tgarrochinho/Code/lumara-frontend/src/lib/ai/embeddings/index.ts` - `generateEmbedding()`
- `/Users/tgarrochinho/Code/lumara-frontend/src/lib/ai/utils/similarity.ts` - `calculateSimilarity()`
- `/Users/tgarrochinho/Code/lumara-frontend/src/lib/ai/registry.ts` - AI provider registry
- Memory schema already defined in existing database setup

**New Code Pattern:**
```typescript
// Example usage in components (Task 37+)
import { useMemories } from '../hooks/useMemories';

function MemoryList() {
  const { memories, createMemory, isLoading } = useMemories();

  // memories automatically updates when database changes!
  return (
    <div>
      {isLoading ? 'Loading...' : memories.map(m => <div>{m.content}</div>)}
    </div>
  );
}
```

## Dependencies

### Internal Dependencies
- **Wave 0.2 Complete:** Database schema, embeddings, AI providers all exist
- **No blockers:** All required infrastructure is ready

### External Dependencies
- `dexie` (4.0.10) - Already installed
- `dexie-react-hooks` (1.1.7) - Already installed
- `@testing-library/react` - Already installed
- `vitest` - Already installed

## Effort Estimate

**Size:** Medium (1 day / 8 hours)

**Breakdown:**
- Database operations wrapper: 2 hours
- `useMemories` hook: 2 hours
- `useConversation` hook: 1.5 hours
- Unit tests (90% coverage): 2.5 hours

**Parallel Work:** This task is **parallelizable** - no dependencies on other tasks. Can be developed and tested independently.

**Risk:** Low - Leveraging existing, tested infrastructure from Wave 0.2.

## Definition of Done

- [ ] All files created and committed to repository
- [ ] TypeScript compilation passes with zero errors
- [ ] ESLint passes with zero warnings
- [ ] Unit tests written for all functions
- [ ] Test coverage >90% for new code
- [ ] All tests pass in CI
- [ ] `createMemory()` verified to generate embeddings automatically
- [ ] `useLiveQuery()` verified to trigger re-renders on DB changes
- [ ] Error handling tested with invalid inputs
- [ ] Code reviewed (self-review checklist completed)
- [ ] Performance tested: memory creation <100ms (excluding embedding)
- [ ] Performance tested: search <200ms for 100 memories
- [ ] Documentation comments added to all public functions
- [ ] Integration verified: Can import and use hooks in test components

**Ready for Task 37:** Once this task is complete, Task 37 (Basic Chat Interface) can begin using `useConversation` hook immediately.

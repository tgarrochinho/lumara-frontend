---
name: Dexie Schema Extension for Embeddings
status: completed
created: 2025-10-14T03:28:21Z
updated: 2025-10-14T13:28:00Z
completed: 2025-10-14T13:28:00Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/28
depends_on: [26]
parallel: false
conflicts_with: []
---

# Task: Dexie Schema Extension for Embeddings

## Description
Extend the existing Dexie database schema to store embeddings with memories. Implement efficient storage, retrieval, and indexing strategies for 384-dimensional embedding vectors.

## Acceptance Criteria
- [ ] Memory type extended with `embedding?: number[]` field
- [ ] Database version incremented to v2
- [ ] Migration preserves existing data
- [ ] Embeddings stored and retrieved correctly
- [ ] Query performance acceptable (<10ms for single memory)
- [ ] Batch operations support (bulk insert/update)

## Technical Details

### Files to Modify
```
src/lib/db.ts                 # Extend schema and types
src/types/memory.ts           # Update Memory interface (if exists)
```

### Implementation

1. **Update Memory Interface**
```typescript
// src/lib/db.ts or src/types/memory.ts
export interface Memory {
  id?: number;                // Auto-increment primary key
  content: string;            // Memory text
  type: 'knowledge' | 'experience' | 'method';
  embedding?: number[];       // 384-dim vector from Transformers.js
  createdAt: Date;
  updatedAt: Date;
  tags?: string[];
  metadata?: Record<string, any>;
}
```

2. **Extend Dexie Schema** (`src/lib/db.ts`)
```typescript
import Dexie, { Table } from 'dexie';

export interface Memory {
  id?: number;
  content: string;
  type: 'knowledge' | 'experience' | 'method';
  embedding?: number[];  // NEW: 384-dimensional vector
  createdAt: Date;
  updatedAt: Date;
  tags?: string[];
  metadata?: Record<string, any>;
}

export class LumaraDatabase extends Dexie {
  memories!: Table<Memory, number>;

  constructor() {
    super('LumaraDB');

    // Version 1: Initial schema (if exists)
    this.version(1).stores({
      // existing schema
    });

    // Version 2: Add embedding support
    this.version(2).stores({
      memories: '++id, content, type, createdAt, updatedAt, *tags',
    }).upgrade(async (trans) => {
      // Migration: existing memories get embedding = undefined
      // Will be generated lazily when needed
      console.log('Upgrading to v2: Adding embedding support');
      // No data transformation needed, new field is optional
    });
  }
}

export const db = new LumaraDatabase();
```

3. **Helper Functions for Embedding Storage**
```typescript
// src/lib/db.ts - Add helper functions

export async function saveMemoryWithEmbedding(
  memory: Omit<Memory, 'id' | 'createdAt' | 'updatedAt'>,
  embedding: number[]
): Promise<number> {
  const now = new Date();

  const id = await db.memories.add({
    ...memory,
    embedding,
    createdAt: now,
    updatedAt: now,
  });

  return id;
}

export async function updateMemoryEmbedding(
  memoryId: number,
  embedding: number[]
): Promise<void> {
  await db.memories.update(memoryId, {
    embedding,
    updatedAt: new Date(),
  });
}

export async function getMemoriesWithEmbeddings(): Promise<Memory[]> {
  return db.memories
    .filter(memory => memory.embedding !== undefined)
    .toArray();
}

export async function getMemoriesWithoutEmbeddings(): Promise<Memory[]> {
  return db.memories
    .filter(memory => memory.embedding === undefined)
    .toArray();
}

export async function batchUpdateEmbeddings(
  updates: Array<{ id: number; embedding: number[] }>
): Promise<void> {
  await db.transaction('rw', db.memories, async () => {
    for (const { id, embedding } of updates) {
      await db.memories.update(id, {
        embedding,
        updatedAt: new Date(),
      });
    }
  });
}
```

4. **Lazy Embedding Generation**
```typescript
// src/lib/db.ts - Add to helper functions

import { generateEmbedding } from './ai/embeddings/transformers';

export async function ensureMemoryHasEmbedding(
  memoryId: number
): Promise<number[]> {
  const memory = await db.memories.get(memoryId);

  if (!memory) {
    throw new Error(`Memory ${memoryId} not found`);
  }

  // Return existing embedding if available
  if (memory.embedding) {
    return memory.embedding;
  }

  // Generate embedding
  const embedding = await generateEmbedding(memory.content);

  // Store embedding
  await db.memories.update(memoryId, {
    embedding,
    updatedAt: new Date(),
  });

  return embedding;
}

export async function ensureAllMemoriesHaveEmbeddings(
  onProgress?: (current: number, total: number) => void
): Promise<void> {
  const memoriesWithoutEmbeddings = await getMemoriesWithoutEmbeddings();

  for (let i = 0; i < memoriesWithoutEmbeddings.length; i++) {
    const memory = memoriesWithoutEmbeddings[i];

    if (memory.id) {
      await ensureMemoryHasEmbedding(memory.id);
    }

    if (onProgress) {
      onProgress(i + 1, memoriesWithoutEmbeddings.length);
    }
  }
}
```

### Migration Strategy

1. **Version 2 Upgrade:**
   - Add `embedding` field to schema
   - Existing memories: `embedding = undefined` (optional field)
   - New memories: Include embedding when created
   - Backfill: Generate embeddings lazily when needed

2. **Data Validation:**
   - Verify embeddings are 384 dimensions
   - Check for NaN or Infinity values
   - Validate embedding normalization

3. **Performance Considerations:**
   - Embeddings are ~3KB each (384 floats Ã— 8 bytes)
   - 1000 memories = ~3MB of embedding data
   - IndexedDB limit: ~50MB per origin (sufficient)

### Testing Strategy
```typescript
describe('Dexie Schema Extension', () => {
  beforeEach(async () => {
    await db.delete();
    await db.open();
  });

  it('stores embeddings with memories', async () => {
    const embedding = new Array(384).fill(0.5);
    const id = await saveMemoryWithEmbedding(
      { content: 'test', type: 'knowledge' },
      embedding
    );

    const memory = await db.memories.get(id);
    expect(memory?.embedding).toHaveLength(384);
  });

  it('handles memories without embeddings', async () => {
    await db.memories.add({
      content: 'test',
      type: 'knowledge',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const memoriesWithout = await getMemoriesWithoutEmbeddings();
    expect(memoriesWithout).toHaveLength(1);
  });

  it('lazy generates embeddings when missing', async () => {
    const id = await db.memories.add({
      content: 'test',
      type: 'knowledge',
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const embedding = await ensureMemoryHasEmbedding(id);
    expect(embedding).toHaveLength(384);

    const memory = await db.memories.get(id);
    expect(memory?.embedding).toBeDefined();
  });
});
```

## Dependencies
- [ ] Task 002 (Embeddings) for generating embeddings
- [ ] Existing Dexie setup (already in project)

## Effort Estimate
- **Size:** S (Small)
- **Hours:** 4-6 hours
- **Parallel:** No - Depends on Task 002

## Definition of Done
- [ ] Database schema upgraded to v2
- [ ] Memory interface includes embedding field
- [ ] Helper functions implemented
- [ ] Migration tested with existing data
- [ ] Lazy embedding generation working
- [ ] Batch operations tested
- [ ] Unit tests passing
- [ ] No data loss during migration

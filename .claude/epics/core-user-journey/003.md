---
name: Memory Extraction & Creation
status: open
created: 2025-10-14T21:12:26Z
updated: 2025-10-14T21:12:26Z
github: null
depends_on: [001, 002]
parallel: false
conflicts_with: []
---

# Task 003: Memory Extraction & Creation

## Description

Implement AI-powered memory extraction from conversations with an edit-before-save workflow. This task connects the conversation interface (Task 002) to the memory database (Task 001) through intelligent content analysis and user confirmation.

**What to Build:**
- Memory extraction logic using AI provider to analyze conversations
- `MemoryExtraction` preview component showing AI-extracted content
- Edit form allowing users to modify before saving
- Save operation generating embeddings and storing in Dexie
- Success feedback and conversation continuation

**Key Feature:** Users can edit AI suggestions before saving - prevents bad memories from entering the system.

## Acceptance Criteria

- [ ] AI analyzes conversation and extracts structured memory data
- [ ] Extraction includes: content, type, tags, confidence score
- [ ] Preview component displays extracted memory for review
- [ ] User can edit all fields (content, type, tags) before saving
- [ ] User can cancel extraction without saving
- [ ] Save button triggers memory creation with embedding generation
- [ ] Success message confirms memory was saved
- [ ] Preview disappears after save/cancel
- [ ] Conversation continues after memory creation
- [ ] Extraction handles AI failures gracefully (fallback to manual)
- [ ] Low confidence extractions (<0.7) trigger manual mode
- [ ] Component integrates seamlessly with ChatInterface
- [ ] All operations are keyboard accessible
- [ ] Unit tests cover extraction logic and error cases
- [ ] Integration tests verify end-to-end flow

## Technical Details

### Files to Create

**1. Memory Extraction Logic**
```typescript
// src/lib/ai/memory-extraction.ts
import { aiRegistry } from './registry';
import type { MemoryType } from '../db/schema';

export interface ExtractedMemory {
  content: string;
  type: MemoryType;
  tags: string[];
  confidence: number;
  reasoning?: string;
}

/**
 * Extract memory from conversation using AI
 *
 * Analyzes conversation context and extracts structured memory data.
 * Returns null if extraction fails or confidence is too low.
 *
 * @param messages - Recent conversation messages
 * @returns ExtractedMemory or null if extraction failed
 */
export async function extractMemoryFromConversation(
  messages: Array<{ role: string; content: string }>
): Promise<ExtractedMemory | null> {
  try {
    const provider = aiRegistry.getProvider('chrome-ai') ??
                    aiRegistry.getBestProvider();

    if (!provider) {
      console.error('No AI provider available for extraction');
      return null;
    }

    // Build extraction prompt
    const conversationContext = messages
      .map(m => `${m.role}: ${m.content}`)
      .join('\n');

    const extractionPrompt = `
Analyze this conversation and extract a memory that should be saved.

CONVERSATION:
${conversationContext}

Extract a memory following these rules:

1. CONTENT: The core fact, insight, or experience (1-2 sentences, clear and self-contained)
2. TYPE: Classify as one of:
   - "knowledge": Facts, concepts, how things work
   - "experience": Personal experiences, events, observations
   - "method": Approaches, strategies, workflows
3. TAGS: 2-5 relevant keywords (lowercase, hyphenated)
4. CONFIDENCE: Your confidence this is worth remembering (0.0-1.0)
5. REASONING: Brief explanation of why this is memorable

Respond ONLY with valid JSON:
{
  "content": "...",
  "type": "knowledge|experience|method",
  "tags": ["tag1", "tag2"],
  "confidence": 0.85,
  "reasoning": "..."
}

If nothing memorable was discussed, respond with:
{"confidence": 0.0}
`;

    const response = await provider.chat(extractionPrompt);

    // Parse JSON response
    const extracted = parseExtractionResponse(response);

    if (!extracted || extracted.confidence < 0.5) {
      return null;
    }

    return extracted;
  } catch (error) {
    console.error('Memory extraction failed:', error);
    return null;
  }
}

/**
 * Parse AI response into ExtractedMemory
 * Handles both JSON and text responses
 */
function parseExtractionResponse(response: string): ExtractedMemory | null {
  try {
    // Try to find JSON in response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    const data = JSON.parse(jsonMatch[0]);

    // Validate structure
    if (typeof data.confidence !== 'number') return null;
    if (data.confidence < 0.5) return null;

    if (!data.content || !data.type || !Array.isArray(data.tags)) {
      return null;
    }

    // Validate type
    const validTypes: MemoryType[] = ['knowledge', 'experience', 'method'];
    if (!validTypes.includes(data.type)) {
      data.type = 'knowledge'; // Default fallback
    }

    return {
      content: data.content.trim(),
      type: data.type as MemoryType,
      tags: data.tags.map((t: string) => t.toLowerCase().trim()),
      confidence: data.confidence,
      reasoning: data.reasoning,
    };
  } catch (error) {
    console.error('Failed to parse extraction response:', error);
    return null;
  }
}

/**
 * Determine if conversation warrants memory extraction
 *
 * Heuristics:
 * - At least 2 messages
 * - Last message from assistant
 * - Some substantive content (>50 chars)
 */
export function shouldExtractMemory(
  messages: Array<{ role: string; content: string }>
): boolean {
  if (messages.length < 2) return false;

  const lastMessage = messages[messages.length - 1];
  if (lastMessage.role !== 'assistant') return false;

  const totalContent = messages
    .map(m => m.content)
    .join(' ')
    .trim();

  return totalContent.length > 50;
}
```

**2. Memory Extraction Component**
```typescript
// src/components/conversation/MemoryExtraction.tsx
import { useState } from 'react';
import { useMemories } from '../../hooks/useMemories';
import type { ExtractedMemory } from '../../lib/ai/memory-extraction';
import type { MemoryType } from '../../lib/db/schema';

export interface MemoryExtractionProps {
  extracted: ExtractedMemory;
  onSave: () => void;
  onCancel: () => void;
}

/**
 * Memory preview and edit component
 *
 * Allows user to review and edit AI-extracted memory before saving.
 * Shows confidence score and extraction reasoning.
 */
export function MemoryExtraction({
  extracted,
  onSave,
  onCancel,
}: MemoryExtractionProps) {
  const { createMemory } = useMemories();

  const [content, setContent] = useState(extracted.content);
  const [type, setType] = useState<MemoryType>(extracted.type);
  const [tags, setTags] = useState<string[]>(extracted.tags);
  const [tagInput, setTagInput] = useState('');
  const [isSaving, setIsSaving] = useState(false);

  const handleSave = async () => {
    if (!content.trim()) return;

    setIsSaving(true);

    try {
      await createMemory({
        content: content.trim(),
        type,
        tags,
      });

      onSave();
    } catch (error) {
      console.error('Failed to save memory:', error);
      alert('Failed to save memory. Please try again.');
    } finally {
      setIsSaving(false);
    }
  };

  const handleAddTag = () => {
    const newTag = tagInput.trim().toLowerCase();
    if (newTag && !tags.includes(newTag)) {
      setTags([...tags, newTag]);
      setTagInput('');
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setTags(tags.filter(t => t !== tagToRemove));
  };

  const handleTagKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleAddTag();
    }
  };

  // Color coding by confidence
  const confidenceColor =
    extracted.confidence >= 0.8 ? 'green' :
    extracted.confidence >= 0.6 ? 'yellow' : 'orange';

  return (
    <div
      className="border-t border-gray-200 bg-blue-50 p-4"
      data-testid="memory-extraction"
    >
      <div className="mx-auto max-w-2xl space-y-4">
        {/* Header */}
        <div className="flex items-start justify-between">
          <div>
            <h3 className="text-lg font-semibold text-gray-900">
              Save as Memory
            </h3>
            <p className="text-sm text-gray-600">
              Review and edit before saving
            </p>
          </div>

          {/* Confidence Badge */}
          <div className={`rounded-full px-3 py-1 text-xs font-medium
            ${confidenceColor === 'green' ? 'bg-green-100 text-green-800' : ''}
            ${confidenceColor === 'yellow' ? 'bg-yellow-100 text-yellow-800' : ''}
            ${confidenceColor === 'orange' ? 'bg-orange-100 text-orange-800' : ''}
          `}>
            {Math.round(extracted.confidence * 100)}% confident
          </div>
        </div>

        {/* Reasoning (if available) */}
        {extracted.reasoning && (
          <div className="text-sm text-gray-600 italic">
            "{extracted.reasoning}"
          </div>
        )}

        {/* Content Editor */}
        <div>
          <label
            htmlFor="memory-content"
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            Content
          </label>
          <textarea
            id="memory-content"
            value={content}
            onChange={e => setContent(e.target.value)}
            rows={3}
            className="w-full rounded-lg border border-gray-300 px-3 py-2
                       focus:border-blue-500 focus:outline-none focus:ring-2
                       focus:ring-blue-500"
            data-testid="memory-content-input"
          />
        </div>

        {/* Type Selector */}
        <div>
          <label
            htmlFor="memory-type"
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            Type
          </label>
          <select
            id="memory-type"
            value={type}
            onChange={e => setType(e.target.value as MemoryType)}
            className="rounded-lg border border-gray-300 px-3 py-2
                       focus:border-blue-500 focus:outline-none focus:ring-2
                       focus:ring-blue-500"
            data-testid="memory-type-select"
          >
            <option value="knowledge">Knowledge</option>
            <option value="experience">Experience</option>
            <option value="method">Method</option>
          </select>
        </div>

        {/* Tags Editor */}
        <div>
          <label
            htmlFor="memory-tags"
            className="block text-sm font-medium text-gray-700 mb-1"
          >
            Tags
          </label>

          {/* Tag List */}
          <div className="flex flex-wrap gap-2 mb-2">
            {tags.map(tag => (
              <span
                key={tag}
                className="inline-flex items-center gap-1 rounded-full
                           bg-blue-100 px-3 py-1 text-sm text-blue-800"
              >
                {tag}
                <button
                  onClick={() => handleRemoveTag(tag)}
                  className="hover:text-blue-900"
                  aria-label={`Remove tag ${tag}`}
                >
                  ×
                </button>
              </span>
            ))}
          </div>

          {/* Add Tag Input */}
          <div className="flex gap-2">
            <input
              id="memory-tags"
              type="text"
              value={tagInput}
              onChange={e => setTagInput(e.target.value)}
              onKeyDown={handleTagKeyDown}
              placeholder="Add tag..."
              className="flex-1 rounded-lg border border-gray-300 px-3 py-2
                         focus:border-blue-500 focus:outline-none focus:ring-2
                         focus:ring-blue-500"
              data-testid="tag-input"
            />
            <button
              onClick={handleAddTag}
              disabled={!tagInput.trim()}
              className="rounded-lg bg-gray-200 px-4 py-2 text-sm font-medium
                         hover:bg-gray-300 disabled:opacity-50
                         disabled:cursor-not-allowed"
              data-testid="add-tag-button"
            >
              Add
            </button>
          </div>
        </div>

        {/* Actions */}
        <div className="flex justify-end gap-3">
          <button
            onClick={onCancel}
            disabled={isSaving}
            className="rounded-lg border border-gray-300 px-4 py-2
                       text-sm font-medium text-gray-700 hover:bg-gray-50
                       disabled:opacity-50 disabled:cursor-not-allowed"
            data-testid="cancel-button"
          >
            Cancel
          </button>
          <button
            onClick={handleSave}
            disabled={isSaving || !content.trim()}
            className="rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium
                       text-white hover:bg-blue-700 disabled:opacity-50
                       disabled:cursor-not-allowed"
            data-testid="save-button"
          >
            {isSaving ? 'Saving...' : 'Save Memory'}
          </button>
        </div>
      </div>
    </div>
  );
}
```

**3. Integration with ChatInterface**
```typescript
// Update src/components/conversation/ChatInterface.tsx
import { useState, useEffect } from 'react';
import { useConversation } from '../../hooks/useConversation';
import { InputField } from './InputField';
import { MemoryExtraction } from './MemoryExtraction';
import {
  extractMemoryFromConversation,
  shouldExtractMemory,
  type ExtractedMemory,
} from '../../lib/ai/memory-extraction';

export function ChatInterface() {
  const { messages, isTyping, sendMessage } = useConversation();
  const [extractedMemory, setExtractedMemory] = useState<ExtractedMemory | null>(null);
  const [isExtracting, setIsExtracting] = useState(false);

  // Auto-extract after AI responses
  useEffect(() => {
    const attemptExtraction = async () => {
      if (isTyping || extractedMemory || isExtracting) return;
      if (!shouldExtractMemory(messages)) return;

      setIsExtracting(true);

      try {
        // Use last 5 messages for context
        const recentMessages = messages.slice(-5);
        const extracted = await extractMemoryFromConversation(recentMessages);

        if (extracted) {
          setExtractedMemory(extracted);
        }
      } catch (error) {
        console.error('Memory extraction failed:', error);
      } finally {
        setIsExtracting(false);
      }
    };

    attemptExtraction();
  }, [messages, isTyping, extractedMemory, isExtracting]);

  const handleMemorySaved = () => {
    setExtractedMemory(null);
    // Show success message (could be a toast notification)
    console.log('Memory saved successfully!');
  };

  const handleMemoryCancelled = () => {
    setExtractedMemory(null);
  };

  const handleSend = async (content: string) => {
    if (!content.trim()) return;
    await sendMessage(content);
  };

  return (
    <div className="flex h-full flex-col bg-white">
      {/* Message List Area */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {/* ... existing message display code ... */}
      </div>

      {/* Memory Extraction Preview (if active) */}
      {extractedMemory && (
        <MemoryExtraction
          extracted={extractedMemory}
          onSave={handleMemorySaved}
          onCancel={handleMemoryCancelled}
        />
      )}

      {/* Input Area */}
      <div className="border-t border-gray-200 p-4">
        <InputField
          onSend={handleSend}
          disabled={isTyping}
        />
      </div>
    </div>
  );
}
```

**4. Tests**
```typescript
// src/lib/ai/__tests__/memory-extraction.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  extractMemoryFromConversation,
  shouldExtractMemory,
} from '../memory-extraction';
import { aiRegistry } from '../registry';

describe('extractMemoryFromConversation', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('extracts memory with valid JSON response', async () => {
    const mockProvider = {
      chat: vi.fn().mockResolvedValue(JSON.stringify({
        content: 'React hooks run on every render',
        type: 'knowledge',
        tags: ['react', 'hooks'],
        confidence: 0.9,
        reasoning: 'Clear technical fact',
      })),
    };

    vi.spyOn(aiRegistry, 'getProvider').mockReturnValue(mockProvider as any);

    const messages = [
      { role: 'user', content: 'Tell me about React hooks' },
      { role: 'assistant', content: 'Hooks run on every render' },
    ];

    const result = await extractMemoryFromConversation(messages);

    expect(result).not.toBeNull();
    expect(result!.content).toBe('React hooks run on every render');
    expect(result!.type).toBe('knowledge');
    expect(result!.confidence).toBe(0.9);
  });

  it('returns null for low confidence', async () => {
    const mockProvider = {
      chat: vi.fn().mockResolvedValue(JSON.stringify({
        confidence: 0.3,
      })),
    };

    vi.spyOn(aiRegistry, 'getProvider').mockReturnValue(mockProvider as any);

    const result = await extractMemoryFromConversation([
      { role: 'user', content: 'Hi' },
      { role: 'assistant', content: 'Hello' },
    ]);

    expect(result).toBeNull();
  });

  it('handles malformed JSON gracefully', async () => {
    const mockProvider = {
      chat: vi.fn().mockResolvedValue('Not JSON at all'),
    };

    vi.spyOn(aiRegistry, 'getProvider').mockReturnValue(mockProvider as any);

    const result = await extractMemoryFromConversation([
      { role: 'user', content: 'Test' },
      { role: 'assistant', content: 'Response' },
    ]);

    expect(result).toBeNull();
  });
});

describe('shouldExtractMemory', () => {
  it('returns true for substantive conversation', () => {
    const messages = [
      { role: 'user', content: 'Tell me about TypeScript generics' },
      { role: 'assistant', content: 'Generics allow type parameters...' },
    ];

    expect(shouldExtractMemory(messages)).toBe(true);
  });

  it('returns false for short conversations', () => {
    const messages = [
      { role: 'user', content: 'Hi' },
    ];

    expect(shouldExtractMemory(messages)).toBe(false);
  });

  it('returns false if last message is from user', () => {
    const messages = [
      { role: 'user', content: 'Question one' },
      { role: 'assistant', content: 'Answer one' },
      { role: 'user', content: 'Question two' },
    ];

    expect(shouldExtractMemory(messages)).toBe(false);
  });
});

// src/components/conversation/__tests__/MemoryExtraction.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { MemoryExtraction } from '../MemoryExtraction';
import * as useMemoriesModule from '../../../hooks/useMemories';

describe('MemoryExtraction', () => {
  const mockExtracted = {
    content: 'Test memory content',
    type: 'knowledge' as const,
    tags: ['test', 'memory'],
    confidence: 0.85,
    reasoning: 'Clear and memorable',
  };

  it('renders extracted memory for review', () => {
    vi.spyOn(useMemoriesModule, 'useMemories').mockReturnValue({
      memories: [],
      isLoading: false,
      createMemory: vi.fn(),
      updateMemory: vi.fn(),
      deleteMemory: vi.fn(),
      searchMemories: vi.fn(),
    });

    render(
      <MemoryExtraction
        extracted={mockExtracted}
        onSave={vi.fn()}
        onCancel={vi.fn()}
      />
    );

    expect(screen.getByDisplayValue('Test memory content')).toBeInTheDocument();
    expect(screen.getByText('test')).toBeInTheDocument();
    expect(screen.getByText('memory')).toBeInTheDocument();
    expect(screen.getByText(/85% confident/i)).toBeInTheDocument();
  });

  it('allows editing content', async () => {
    const user = userEvent.setup();
    vi.spyOn(useMemoriesModule, 'useMemories').mockReturnValue({
      memories: [],
      isLoading: false,
      createMemory: vi.fn(),
      updateMemory: vi.fn(),
      deleteMemory: vi.fn(),
      searchMemories: vi.fn(),
    });

    render(
      <MemoryExtraction
        extracted={mockExtracted}
        onSave={vi.fn()}
        onCancel={vi.fn()}
      />
    );

    const input = screen.getByTestId('memory-content-input');
    await user.clear(input);
    await user.type(input, 'Edited content');

    expect(input).toHaveValue('Edited content');
  });

  it('saves memory with createMemory hook', async () => {
    const user = userEvent.setup();
    const createMemory = vi.fn().mockResolvedValue(1);
    const onSave = vi.fn();

    vi.spyOn(useMemoriesModule, 'useMemories').mockReturnValue({
      memories: [],
      isLoading: false,
      createMemory,
      updateMemory: vi.fn(),
      deleteMemory: vi.fn(),
      searchMemories: vi.fn(),
    });

    render(
      <MemoryExtraction
        extracted={mockExtracted}
        onSave={onSave}
        onCancel={vi.fn()}
      />
    );

    await user.click(screen.getByTestId('save-button'));

    await waitFor(() => {
      expect(createMemory).toHaveBeenCalledWith({
        content: 'Test memory content',
        type: 'knowledge',
        tags: ['test', 'memory'],
      });
      expect(onSave).toHaveBeenCalled();
    });
  });

  it('calls onCancel when cancelled', async () => {
    const user = userEvent.setup();
    const onCancel = vi.fn();

    vi.spyOn(useMemoriesModule, 'useMemories').mockReturnValue({
      memories: [],
      isLoading: false,
      createMemory: vi.fn(),
      updateMemory: vi.fn(),
      deleteMemory: vi.fn(),
      searchMemories: vi.fn(),
    });

    render(
      <MemoryExtraction
        extracted={mockExtracted}
        onSave={vi.fn()}
        onCancel={onCancel}
      />
    );

    await user.click(screen.getByTestId('cancel-button'));

    expect(onCancel).toHaveBeenCalled();
  });
});
```

### Integration Points

**Dependencies:**
- Task 001: `useMemories` hook, `createMemory()` function
- Task 002: `ChatInterface` component to integrate extraction UI
- Wave 0.2: AI provider system, embedding generation

**Data Flow:**
1. User chats → AI responds
2. `shouldExtractMemory()` checks if extraction warranted
3. `extractMemoryFromConversation()` calls AI for structured extraction
4. `MemoryExtraction` component shows preview
5. User edits and confirms
6. `createMemory()` saves with embedding
7. Dexie triggers reactive update in memory list (Task 004)

## Dependencies

### Internal Dependencies
- **Task 001 (Database Operations & Hooks):** REQUIRED
  - Uses `useMemories` hook
  - Uses `createMemory()` function
- **Task 002 (Basic Chat Interface):** REQUIRED
  - Integrates into `ChatInterface`
  - Uses message history

### External Dependencies
- All dependencies from Tasks 001 and 002
- No new packages required

## Effort Estimate

**Size:** Medium (1 day / 8 hours)

**Breakdown:**
- Memory extraction logic: 2.5 hours
- `MemoryExtraction` component: 2.5 hours
- ChatInterface integration: 1 hour
- Unit tests: 1.5 hours
- Integration testing: 0.5 hours

**Parallel Work:** This task is **sequential** - depends on Tasks 001 AND 002 completing first.

**Risk:** Medium - AI extraction quality depends on Chrome AI prompt engineering. Mitigation: Always allow manual editing.

## Definition of Done

- [ ] `memory-extraction.ts` created with extraction logic
- [ ] `MemoryExtraction.tsx` component created
- [ ] `ChatInterface` updated with extraction integration
- [ ] AI extraction produces valid structured data
- [ ] Low confidence (<0.5) extractions are ignored
- [ ] Preview shows all extracted fields editable
- [ ] User can edit content, type, and tags
- [ ] User can add/remove tags
- [ ] Save button creates memory with embedding
- [ ] Cancel button dismisses preview without saving
- [ ] Success feedback displays after save
- [ ] Extraction handles AI errors gracefully
- [ ] All operations are keyboard accessible
- [ ] Unit tests achieve >90% coverage
- [ ] All tests pass in CI
- [ ] TypeScript compilation passes
- [ ] ESLint passes with zero warnings
- [ ] Manual testing with Chrome AI completed
- [ ] End-to-end flow verified: chat → extract → edit → save → see in list
- [ ] Code reviewed (self-review checklist completed)

**Milestone:** Once complete, the core user journey is functional - users can create memories through conversation!

---
name: Basic Chat Interface
status: open
created: 2025-10-14T21:12:26Z
updated: 2025-10-14T21:25:10Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/37
depends_on: [35]
parallel: false
conflicts_with: []
---

# Task 37: Basic Chat Interface

## Description

Build a functional conversational interface that allows users to chat with Lumara's AI. This task creates the UI layer for the conversation feature, connecting the `useConversation` hook (from Task 35) with React components.

**What to Build:**
- `ChatInterface` component - main container orchestrating conversation flow
- `InputField` component - multiline textarea with send button
- Basic message display (simple list, no polish yet)
- Integration with AI provider via existing hook
- Loading states and error handling

**Focus:** Functional and working. UI polish comes in Task 8. Goal is to verify the conversation loop works end-to-end.

## Acceptance Criteria

- [ ] User can type messages in multiline input field
- [ ] Send button triggers message submission
- [ ] Enter key sends message (Shift+Enter for new line)
- [ ] User messages appear in conversation immediately
- [ ] AI responses appear after processing
- [ ] Loading indicator shows while AI is typing
- [ ] Error messages display if AI fails
- [ ] Input field clears after sending
- [ ] Conversation history persists during session
- [ ] Component is responsive (basic mobile support)
- [ ] All interactive elements are keyboard accessible
- [ ] Component renders without console errors
- [ ] TypeScript types are properly defined
- [ ] Unit tests cover main interaction flows

## Technical Details

### Files to Create

**1. Chat Interface Component**
```typescript
// src/components/conversation/ChatInterface.tsx
import { useConversation } from '../../hooks/useConversation';
import { InputField } from './InputField';
import type { Message } from '../../hooks/useConversation';

/**
 * Main chat interface component
 *
 * Orchestrates conversation flow between user and AI.
 * Uses useConversation hook for state management.
 */
export function ChatInterface() {
  const { messages, isTyping, sendMessage } = useConversation();

  const handleSend = async (content: string) => {
    if (!content.trim()) return;
    await sendMessage(content);
  };

  return (
    <div className="flex h-full flex-col bg-white">
      {/* Message List Area */}
      <div
        className="flex-1 overflow-y-auto p-4 space-y-4"
        data-testid="message-list"
      >
        {messages.length === 0 ? (
          <EmptyState />
        ) : (
          messages.map(message => (
            <MessageBubble key={message.id} message={message} />
          ))
        )}

        {/* Typing Indicator */}
        {isTyping && (
          <div className="flex items-center space-x-2 text-gray-500">
            <div className="flex space-x-1">
              <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" />
              <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-100" />
              <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-200" />
            </div>
            <span className="text-sm">Lumara is thinking...</span>
          </div>
        )}
      </div>

      {/* Input Area */}
      <div className="border-t border-gray-200 p-4">
        <InputField
          onSend={handleSend}
          disabled={isTyping}
        />
      </div>
    </div>
  );
}

/**
 * Empty state when no messages exist
 */
function EmptyState() {
  return (
    <div className="flex flex-col items-center justify-center h-full text-center">
      <div className="max-w-md space-y-4">
        <h2 className="text-2xl font-semibold text-gray-900">
          Start a conversation
        </h2>
        <p className="text-gray-600">
          Tell me something you'd like to remember. I'll help you
          capture it as a memory you can reference later.
        </p>
        <div className="text-sm text-gray-500">
          <p className="font-medium mb-2">Try asking:</p>
          <ul className="space-y-1">
            <li>"I learned that React hooks run on every render"</li>
            <li>"I prefer morning work sessions for deep focus"</li>
            <li>"My debugging approach is to check the console first"</li>
          </ul>
        </div>
      </div>
    </div>
  );
}

/**
 * Simple message bubble (basic version, polish in Task 8)
 */
interface MessageBubbleProps {
  message: Message;
}

function MessageBubble({ message }: MessageBubbleProps) {
  const isUser = message.role === 'user';

  return (
    <div
      className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}
      data-testid={`message-${message.role}`}
    >
      <div
        className={`max-w-[70%] rounded-lg px-4 py-2 ${
          isUser
            ? 'bg-blue-600 text-white'
            : 'bg-gray-100 text-gray-900'
        }`}
      >
        <p className="text-sm whitespace-pre-wrap">{message.content}</p>
        <time className={`text-xs mt-1 block ${
          isUser ? 'text-blue-100' : 'text-gray-500'
        }`}>
          {message.timestamp.toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit'
          })}
        </time>
      </div>
    </div>
  );
}
```

**2. Input Field Component**
```typescript
// src/components/conversation/InputField.tsx
import { useState, useRef, KeyboardEvent } from 'react';

export interface InputFieldProps {
  onSend: (message: string) => void;
  disabled?: boolean;
  placeholder?: string;
}

/**
 * Multiline input field for chat messages
 *
 * Features:
 * - Auto-expanding textarea
 * - Enter to send, Shift+Enter for new line
 * - Send button
 * - Disabled state during AI processing
 */
export function InputField({
  onSend,
  disabled = false,
  placeholder = "Type your message..."
}: InputFieldProps) {
  const [value, setValue] = useState('');
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSend = () => {
    if (!value.trim() || disabled) return;

    onSend(value);
    setValue('');

    // Reset textarea height
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
    }
  };

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    // Send on Enter (but not Shift+Enter)
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setValue(e.target.value);

    // Auto-expand textarea
    const textarea = e.target;
    textarea.style.height = 'auto';
    textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
  };

  return (
    <div className="flex items-end space-x-2">
      <div className="flex-1 relative">
        <textarea
          ref={textareaRef}
          value={value}
          onChange={handleChange}
          onKeyDown={handleKeyDown}
          disabled={disabled}
          placeholder={placeholder}
          rows={1}
          className="w-full resize-none rounded-lg border border-gray-300
                     px-4 py-3 pr-12 focus:border-blue-500 focus:outline-none
                     focus:ring-2 focus:ring-blue-500 disabled:bg-gray-50
                     disabled:cursor-not-allowed"
          data-testid="chat-input"
          aria-label="Message input"
        />
      </div>

      <button
        onClick={handleSend}
        disabled={disabled || !value.trim()}
        className="rounded-lg bg-blue-600 px-6 py-3 text-white
                   hover:bg-blue-700 focus:outline-none focus:ring-2
                   focus:ring-blue-500 focus:ring-offset-2
                   disabled:bg-gray-300 disabled:cursor-not-allowed
                   transition-colors"
        data-testid="send-button"
        aria-label="Send message"
      >
        Send
      </button>
    </div>
  );
}
```

**3. Component Tests**
```typescript
// src/components/conversation/__tests__/ChatInterface.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ChatInterface } from '../ChatInterface';
import * as useConversationModule from '../../../hooks/useConversation';

describe('ChatInterface', () => {
  it('renders empty state initially', () => {
    vi.spyOn(useConversationModule, 'useConversation').mockReturnValue({
      messages: [],
      isTyping: false,
      sendMessage: vi.fn(),
      clearMessages: vi.fn(),
    });

    render(<ChatInterface />);

    expect(screen.getByText(/start a conversation/i)).toBeInTheDocument();
  });

  it('displays messages in conversation', () => {
    vi.spyOn(useConversationModule, 'useConversation').mockReturnValue({
      messages: [
        {
          id: '1',
          role: 'user',
          content: 'Hello',
          timestamp: new Date(),
        },
        {
          id: '2',
          role: 'assistant',
          content: 'Hi there!',
          timestamp: new Date(),
        },
      ],
      isTyping: false,
      sendMessage: vi.fn(),
      clearMessages: vi.fn(),
    });

    render(<ChatInterface />);

    expect(screen.getByText('Hello')).toBeInTheDocument();
    expect(screen.getByText('Hi there!')).toBeInTheDocument();
  });

  it('shows typing indicator when AI is processing', () => {
    vi.spyOn(useConversationModule, 'useConversation').mockReturnValue({
      messages: [],
      isTyping: true,
      sendMessage: vi.fn(),
      clearMessages: vi.fn(),
    });

    render(<ChatInterface />);

    expect(screen.getByText(/lumara is thinking/i)).toBeInTheDocument();
  });

  it('sends message when user submits', async () => {
    const sendMessage = vi.fn();
    vi.spyOn(useConversationModule, 'useConversation').mockReturnValue({
      messages: [],
      isTyping: false,
      sendMessage,
      clearMessages: vi.fn(),
    });

    const user = userEvent.setup();
    render(<ChatInterface />);

    const input = screen.getByTestId('chat-input');
    const sendButton = screen.getByTestId('send-button');

    await user.type(input, 'Test message');
    await user.click(sendButton);

    expect(sendMessage).toHaveBeenCalledWith('Test message');
  });

  it('disables input while AI is typing', () => {
    vi.spyOn(useConversationModule, 'useConversation').mockReturnValue({
      messages: [],
      isTyping: true,
      sendMessage: vi.fn(),
      clearMessages: vi.fn(),
    });

    render(<ChatInterface />);

    const input = screen.getByTestId('chat-input');
    const sendButton = screen.getByTestId('send-button');

    expect(input).toBeDisabled();
    expect(sendButton).toBeDisabled();
  });
});

// src/components/conversation/__tests__/InputField.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { InputField } from '../InputField';

describe('InputField', () => {
  it('renders textarea and send button', () => {
    render(<InputField onSend={vi.fn()} />);

    expect(screen.getByTestId('chat-input')).toBeInTheDocument();
    expect(screen.getByTestId('send-button')).toBeInTheDocument();
  });

  it('calls onSend when send button clicked', async () => {
    const onSend = vi.fn();
    const user = userEvent.setup();

    render(<InputField onSend={onSend} />);

    const input = screen.getByTestId('chat-input');
    await user.type(input, 'Test message');
    await user.click(screen.getByTestId('send-button'));

    expect(onSend).toHaveBeenCalledWith('Test message');
  });

  it('calls onSend when Enter key pressed', async () => {
    const onSend = vi.fn();
    const user = userEvent.setup();

    render(<InputField onSend={onSend} />);

    const input = screen.getByTestId('chat-input');
    await user.type(input, 'Test message{Enter}');

    expect(onSend).toHaveBeenCalledWith('Test message');
  });

  it('adds new line when Shift+Enter pressed', async () => {
    const onSend = vi.fn();
    const user = userEvent.setup();

    render(<InputField onSend={onSend} />);

    const input = screen.getByTestId('chat-input') as HTMLTextAreaElement;
    await user.type(input, 'Line 1{Shift>}{Enter}{/Shift}Line 2');

    expect(input.value).toBe('Line 1\nLine 2');
    expect(onSend).not.toHaveBeenCalled();
  });

  it('clears input after sending', async () => {
    const onSend = vi.fn();
    const user = userEvent.setup();

    render(<InputField onSend={onSend} />);

    const input = screen.getByTestId('chat-input') as HTMLTextAreaElement;
    await user.type(input, 'Test');
    await user.click(screen.getByTestId('send-button'));

    expect(input.value).toBe('');
  });

  it('does not send empty messages', async () => {
    const onSend = vi.fn();
    const user = userEvent.setup();

    render(<InputField onSend={onSend} />);

    await user.click(screen.getByTestId('send-button'));

    expect(onSend).not.toHaveBeenCalled();
  });

  it('disables input when disabled prop is true', () => {
    render(<InputField onSend={vi.fn()} disabled />);

    const input = screen.getByTestId('chat-input');
    const button = screen.getByTestId('send-button');

    expect(input).toBeDisabled();
    expect(button).toBeDisabled();
  });
});
```

### Component Structure

```
src/components/conversation/
├── ChatInterface.tsx          # Main container (exports ChatInterface)
├── InputField.tsx             # Input component (exports InputField)
└── __tests__/
    ├── ChatInterface.test.tsx
    └── InputField.test.tsx
```

### Integration Points

**Dependencies:**
- `useConversation` hook from Task 35
- AI provider system from Wave 0.2 (used by hook)

**Used By:**
- Task 38 (Memory Extraction) - will add extraction UI to ChatInterface
- Task 33 (Layout & Polish) - will integrate into AppLayout

## Dependencies

### Internal Dependencies
- **Task 35 (Database Operations & Hooks):** REQUIRED - Must be complete
  - Uses `useConversation` hook
  - Cannot start until hook is implemented and tested

### External Dependencies
- `react` (19.0.0) - Already installed
- `@testing-library/react` - Already installed
- `@testing-library/user-event` - Already installed
- `vitest` - Already installed

## Effort Estimate

**Size:** Medium (1 day / 8 hours)

**Breakdown:**
- `ChatInterface` component: 2 hours
- `InputField` component: 2 hours
- Basic styling (Tailwind): 1.5 hours
- Component tests: 2 hours
- Integration testing: 0.5 hours

**Parallel Work:** This task is **sequential** - depends on Task 35 completing first.

**Risk:** Low - Standard React component development, well-understood patterns.

## Definition of Done

- [ ] `ChatInterface.tsx` created and rendering correctly
- [ ] `InputField.tsx` created with all keyboard interactions
- [ ] Empty state displays when no messages
- [ ] Messages display in conversation order
- [ ] Typing indicator shows during AI processing
- [ ] User can send messages via button or Enter key
- [ ] Shift+Enter adds new line without sending
- [ ] Input clears after sending
- [ ] Input disables while AI is processing
- [ ] All components are keyboard accessible
- [ ] Component tests achieve >90% coverage
- [ ] All tests pass in CI
- [ ] TypeScript compilation passes with zero errors
- [ ] ESLint passes with zero warnings
- [ ] Components render without console errors
- [ ] Responsive on mobile viewports (>375px width)
- [ ] Manual testing completed with Chrome AI
- [ ] Code reviewed (self-review checklist completed)

**Ready for Task 38:** Once complete, Task 38 can build the memory extraction flow on top of this interface.

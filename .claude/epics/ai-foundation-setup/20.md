---
name: Testing Infrastructure for AI System
status: complete
created: 2025-10-14T03:28:21Z
updated: 2025-10-14T14:40:00Z
completed: 2025-10-14T14:40:00Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/20
depends_on: [001, 002, 003]
parallel: true
conflicts_with: []
---

# Task: Testing Infrastructure for AI System

## Description
Create comprehensive test suite for AI infrastructure including unit tests with mocks, integration tests, and performance benchmarks. Ensure >80% code coverage and validate all core functionality.

## Acceptance Criteria
- [ ] Unit tests for all AI services (>80% coverage)
- [ ] MockAIProvider for testing without real AI
- [ ] Integration tests for end-to-end flows
- [ ] Performance benchmarks validate targets
- [ ] Tests run in CI/CD (no Chrome AI dependency)
- [ ] Test documentation complete

## Technical Details

### Files to Create
```
src/lib/ai/__tests__/
├── provider.test.ts         # Provider abstraction tests
├── embeddings.test.ts       # Embedding generation tests
├── similarity.test.ts       # Similarity calculation tests
├── contradiction.test.ts    # Contradiction detection tests
└── integration.test.ts      # End-to-end tests

src/lib/ai/providers/
└── mock.ts                  # MockAIProvider for testing
```

### Implementation

1. **MockAIProvider** (`src/lib/ai/providers/mock.ts`)
```typescript
import { BaseProvider } from './base';
import { ProviderConfig, ProviderHealth } from '../types';

export class MockAIProvider extends BaseProvider {
  name = 'Mock AI Provider';
  type = 'local' as const;
  requiresApiKey = false;

  capabilities = {
    chat: true,
    embeddings: true,
    streaming: false,
    multimodal: false,
  };

  private responses: Map<string, string> = new Map();
  private embeddings: Map<string, number[]> = new Map();

  // Configure mock responses
  setResponse(prompt: string, response: string): void {
    this.responses.set(prompt, response);
  }

  setEmbedding(text: string, embedding: number[]): void {
    this.embeddings.set(text, embedding);
  }

  async initialize(config?: ProviderConfig): Promise<void> {
    this.initialized = true;
  }

  async chat(message: string): Promise<string> {
    const response = this.responses.get(message);
    if (response) return response;

    // Default mock response
    return `Mock response to: ${message}`;
  }

  async embed(text: string): Promise<number[]> {
    const embedding = this.embeddings.get(text);
    if (embedding) return embedding;

    // Default: random 384-dim vector
    return Array.from({ length: 384 }, () => Math.random());
  }

  async healthCheck(): Promise<ProviderHealth> {
    return {
      available: this.initialized,
      status: 'ready',
      lastChecked: new Date(),
    };
  }

  async dispose(): Promise<void> {
    this.initialized = false;
    this.responses.clear();
    this.embeddings.clear();
  }
}
```

2. **Provider Tests** (`src/lib/ai/__tests__/provider.test.ts`)
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { MockAIProvider } from '../providers/mock';
import { selectProvider } from '../registry';

describe('AIProvider', () => {
  let provider: MockAIProvider;

  beforeEach(() => {
    provider = new MockAIProvider();
  });

  it('initializes successfully', async () => {
    await provider.initialize();
    expect(provider.isReady()).toBe(true);
  });

  it('generates chat responses', async () => {
    await provider.initialize();
    provider.setResponse('test', 'mock response');

    const response = await provider.chat('test');
    expect(response).toBe('mock response');
  });

  it('generates embeddings', async () => {
    await provider.initialize();
    const testEmbedding = new Array(384).fill(0.5);
    provider.setEmbedding('test', testEmbedding);

    const embedding = await provider.embed('test');
    expect(embedding).toHaveLength(384);
    expect(embedding).toEqual(testEmbedding);
  });

  it('health check returns correct status', async () => {
    const health = await provider.healthCheck();
    expect(health.available).toBe(false);

    await provider.initialize();

    const healthAfter = await provider.healthCheck();
    expect(healthAfter.available).toBe(true);
    expect(healthAfter.status).toBe('ready');
  });
});
```

3. **Embeddings Tests** (`src/lib/ai/__tests__/embeddings.test.ts`)
```typescript
import { describe, it, expect, vi } from 'vitest';
import { generateEmbedding } from '../embeddings/transformers';
import { embeddingCache } from '../embeddings/cache';

describe('Embeddings', () => {
  it('generates 384-dimensional embeddings', async () => {
    const embedding = await generateEmbedding('test text');
    expect(embedding).toHaveLength(384);
  });

  it('caches embeddings correctly', async () => {
    const text = 'cached text';

    // First call
    const embedding1 = await generateEmbedding(text);

    // Second call should use cache
    const embedding2 = await generateEmbedding(text);

    expect(embedding1).toEqual(embedding2);
    expect(embeddingCache.has(text)).toBe(true);
  });

  it('normalizes embeddings', async () => {
    const embedding = await generateEmbedding('test');

    // Check if normalized (magnitude ~1)
    const magnitude = Math.sqrt(
      embedding.reduce((sum, val) => sum + val * val, 0)
    );

    expect(magnitude).toBeCloseTo(1.0, 2);
  });
});
```

4. **Similarity Tests** (`src/lib/ai/__tests__/similarity.test.ts`)
```typescript
import { describe, it, expect } from 'vitest';
import { cosineSimilarity, findSimilar } from '../utils/similarity';

describe('Similarity', () => {
  it('calculates cosine similarity correctly', () => {
    // Identical vectors = 1.0
    expect(cosineSimilarity([1, 0, 0], [1, 0, 0])).toBeCloseTo(1.0);

    // Orthogonal vectors = 0.0
    expect(cosineSimilarity([1, 0, 0], [0, 1, 0])).toBeCloseTo(0.0);

    // Opposite vectors = -1.0
    expect(cosineSimilarity([1, 0, 0], [-1, 0, 0])).toBeCloseTo(-1.0);
  });

  it('finds similar memories above threshold', async () => {
    const queryEmbedding = [1, 0, 0];
    const memories = [
      { id: '1', content: 'a', embedding: [0.9, 0.1, 0] },
      { id: '2', content: 'b', embedding: [0, 1, 0] },
      { id: '3', content: 'c', embedding: [1, 0, 0] },
    ];

    const similar = await findSimilar(queryEmbedding, memories, {
      threshold: 0.8,
    });

    expect(similar).toHaveLength(2); // Should find '1' and '3'
    expect(similar[0].id).toBe('3'); // Exact match first
  });

  it('respects similarity threshold', async () => {
    const queryEmbedding = [1, 0, 0];
    const memories = [
      { id: '1', content: 'a', embedding: [0.5, 0.5, 0] },
    ];

    const highThreshold = await findSimilar(queryEmbedding, memories, {
      threshold: 0.9,
    });
    expect(highThreshold).toHaveLength(0);

    const lowThreshold = await findSimilar(queryEmbedding, memories, {
      threshold: 0.5,
    });
    expect(lowThreshold).toHaveLength(1);
  });
});
```

5. **Integration Tests** (`src/lib/ai/__tests__/integration.test.ts`)
```typescript
import { describe, it, expect } from 'vitest';
import { MockAIProvider } from '../providers/mock';
import { generateEmbedding } from '../embeddings/transformers';
import { detectContradictions } from '../utils/contradiction';

describe('AI Integration', () => {
  it('full flow: chat → embedding → similarity → storage', async () => {
    const provider = new MockAIProvider();
    await provider.initialize();

    // 1. Chat
    const response = await provider.chat('test message');
    expect(response).toBeDefined();

    // 2. Generate embedding
    const embedding = await generateEmbedding(response);
    expect(embedding).toHaveLength(384);

    // 3. Check similarity (would check against DB in real flow)
    // 4. Store (would save to Dexie in real flow)
  });

  it('detects contradictions in full flow', async () => {
    const provider = new MockAIProvider();
    await provider.initialize();

    // Set up mock contradiction response
    provider.setResponse(
      expect.stringContaining('contradict'),
      JSON.stringify({
        contradicts: true,
        confidence: 90,
        explanation: 'Direct contradiction',
      })
    );

    const embedding1 = new Array(384).fill(0.5);
    const embedding2 = new Array(384).fill(0.6);

    const contradictions = await detectContradictions(
      'new',
      'Coffee is healthy',
      embedding1,
      [{ id: 'old', content: 'Coffee is unhealthy', embedding: embedding2 }],
      provider
    );

    expect(contradictions).toHaveLength(1);
    expect(contradictions[0].contradicts).toBe(true);
  });
});
```

### Performance Benchmarks
```typescript
describe('Performance', () => {
  it('embedding generation <100ms', async () => {
    const start = performance.now();
    await generateEmbedding('test');
    const duration = performance.now() - start;

    expect(duration).toBeLessThan(100);
  });

  it('similarity search <50ms for 1000 memories', async () => {
    const query = new Array(384).fill(0.5);
    const memories = Array.from({ length: 1000 }, (_, i) => ({
      id: `${i}`,
      content: `memory ${i}`,
      embedding: new Array(384).fill(Math.random()),
    }));

    const start = performance.now();
    await findSimilar(query, memories);
    const duration = performance.now() - start;

    expect(duration).toBeLessThan(50);
  });
});
```

## Dependencies
- [ ] Vitest already configured
- [ ] Tasks 001-003 complete for testing

## Effort Estimate
- **Size:** M (Medium)
- **Hours:** 10-14 hours
- **Parallel:** Yes - Can start after Tasks 001-003

## Definition of Done
- [ ] All tests written and passing
- [ ] >80% code coverage
- [ ] MockAIProvider working
- [ ] Integration tests complete
- [ ] Performance benchmarks validated
- [ ] Tests run in CI/CD
- [ ] Test documentation written

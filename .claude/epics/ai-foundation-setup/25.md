---
name: AI Provider Infrastructure & Abstraction Layer
status: open
created: 2025-10-14T03:28:21Z
updated: 2025-10-14T03:44:37Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/25
depends_on: []
parallel: true
conflicts_with: []
---

# Task: AI Provider Infrastructure & Abstraction Layer

## Description
Create the foundational AI provider abstraction system that enables easy addition of multiple AI providers (Chrome AI, Gemini API, LM Studio, OpenAI, Claude) in the future. Implement the base infrastructure with only ChromeAIProvider for v1, but design the architecture to support any provider.

## Acceptance Criteria
- [ ] AIProvider interface defined with all required methods (chat, embed, initialize, healthCheck)
- [ ] BaseProvider abstract class implements common functionality
- [ ] ChromeAIProvider fully implements interface for Chrome AI (Gemini Nano)
- [ ] Provider registry system supports dynamic provider selection
- [ ] Origin Trial token added to index.html
- [ ] Provider capabilities system (chat, embeddings, streaming, multimodal)
- [ ] Health check system validates provider availability
- [ ] All code is TypeScript strict with zero `any` types

## Technical Details

### Files to Create
```
src/lib/ai/
├── types.ts                     # AIProvider interface, ProviderConfig, ProviderHealth
├── registry.ts                  # Provider selection and registration logic
├── providers/
│   ├── base.ts                  # BaseProvider abstract class
│   └── chrome-ai.ts             # ChromeAIProvider implementation
└── utils/
    └── provider-helpers.ts      # Helper functions for provider management
```

### Key Implementation Steps

1. **Define AIProvider Interface** (`src/lib/ai/types.ts`)
```typescript
export interface AIProvider {
  readonly name: string;
  readonly type: 'local' | 'cloud' | 'hosted';
  readonly requiresApiKey: boolean;

  capabilities: {
    chat: boolean;
    embeddings: boolean;
    streaming: boolean;
    multimodal: boolean;
  };

  // Core operations
  chat(message: string, context?: string[]): Promise<string>;
  embed(text: string): Promise<number[]>;

  // Lifecycle
  initialize(config?: ProviderConfig): Promise<void>;
  dispose(): Promise<void>;
  healthCheck(): Promise<ProviderHealth>;
}

export interface ProviderConfig {
  apiKey?: string;
  modelName?: string;
  temperature?: number;
  maxTokens?: number;
}

export interface ProviderHealth {
  available: boolean;
  status: 'ready' | 'initializing' | 'error' | 'unavailable';
  message?: string;
  lastChecked: Date;
}
```

2. **Implement BaseProvider** (`src/lib/ai/providers/base.ts`)
```typescript
export abstract class BaseProvider implements AIProvider {
  abstract readonly name: string;
  abstract readonly type: 'local' | 'cloud' | 'hosted';
  abstract readonly requiresApiKey: boolean;
  abstract capabilities: AICapabilities;

  protected initialized = false;
  protected lastHealth: ProviderHealth | null = null;

  async healthCheck(): Promise<ProviderHealth> {
    // Default implementation, can be overridden
    return {
      available: this.initialized,
      status: this.initialized ? 'ready' : 'unavailable',
      lastChecked: new Date(),
    };
  }

  // Child classes implement these
  abstract chat(message: string, context?: string[]): Promise<string>;
  abstract embed(text: string): Promise<number[]>;
  abstract initialize(config?: ProviderConfig): Promise<void>;
  abstract dispose(): Promise<void>;
}
```

3. **Implement ChromeAIProvider** (`src/lib/ai/providers/chrome-ai.ts`)
```typescript
export class ChromeAIProvider extends BaseProvider {
  name = 'Chrome AI (Gemini Nano)';
  type = 'local' as const;
  requiresApiKey = false;

  capabilities = {
    chat: true,
    embeddings: false, // Uses Transformers.js separately
    streaming: false,
    multimodal: false,
  };

  private session: any = null;

  async initialize(): Promise<void> {
    if (!('ai' in window)) {
      throw new Error('Chrome AI not available. Use Chrome Canary/Dev with Origin Trial enabled.');
    }

    const status = await (window as any).ai.canCreateTextSession();
    if (status !== 'readily') {
      throw new Error(`Chrome AI not ready: ${status}`);
    }

    this.session = await (window as any).ai.createTextSession();
    this.initialized = true;
  }

  async chat(message: string, context?: string[]): Promise<string> {
    if (!this.initialized || !this.session) {
      await this.initialize();
    }

    let prompt = message;
    if (context?.length) {
      prompt = `Context:\n${context.join('\n\n')}\n\nUser: ${message}`;
    }

    const response = await this.session.prompt(prompt);
    return response;
  }

  async embed(text: string): Promise<number[]> {
    throw new Error('ChromeAIProvider does not support embeddings. Use Transformers.js.');
  }

  async dispose(): Promise<void> {
    // Chrome AI sessions don't need explicit cleanup
    this.session = null;
    this.initialized = false;
  }
}
```

4. **Create Provider Registry** (`src/lib/ai/registry.ts`)
```typescript
import { AIProvider } from './types';
import { ChromeAIProvider } from './providers/chrome-ai';

export const providerRegistry = {
  'chrome-ai': ChromeAIProvider,
  // Future providers will be added here
  // 'gemini': GeminiAPIProvider,
  // 'lm-studio': LMStudioProvider,
};

export async function selectProvider(
  preferredProvider?: keyof typeof providerRegistry
): Promise<AIProvider> {
  // Try preferred provider first
  if (preferredProvider && providerRegistry[preferredProvider]) {
    const ProviderClass = providerRegistry[preferredProvider];
    const provider = new ProviderClass();

    try {
      await provider.initialize();
      const health = await provider.healthCheck();
      if (health.available) {
        return provider;
      }
    } catch (e) {
      console.warn(`Preferred provider ${preferredProvider} failed:`, e);
    }
  }

  // Fallback: Try all providers in order
  for (const [name, ProviderClass] of Object.entries(providerRegistry)) {
    try {
      const provider = new ProviderClass();
      await provider.initialize();
      const health = await provider.healthCheck();
      if (health.available) {
        return provider;
      }
    } catch (e) {
      continue;
    }
  }

  throw new Error('No AI provider available');
}
```

5. **Add Origin Trial Token** (`index.html`)
```html
<head>
  <meta http-equiv="origin-trial" content="YOUR_ACTUAL_TOKEN_HERE">
  <!-- ... rest of head -->
</head>
```

### Integration Points
- Will be used by embeddings system (Task 002)
- Will be used by UI components (Task 005)
- Settings UI will use registry (future)

## Dependencies
- [ ] Chrome Prompt API Origin Trial token obtained
- [ ] TypeScript 5.9+ configured (already done)
- [ ] No external package dependencies for this task

## Effort Estimate
- **Size:** M (Medium)
- **Hours:** 12-16 hours
- **Parallel:** Yes - Can work independently

## Definition of Done
- [ ] All TypeScript files created with zero `any` types
- [ ] ChromeAIProvider successfully creates chat sessions
- [ ] Provider registry can select and initialize providers
- [ ] Health checks work correctly
- [ ] Unit tests written for provider abstraction (mocks)
- [ ] Origin Trial token added and tested
- [ ] Code compiles with no TypeScript errors
- [ ] Documentation comments on all public interfaces

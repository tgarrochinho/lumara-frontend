---
name: Error Handling & Health Checks
status: open
created: 2025-10-14T03:28:21Z
updated: 2025-10-14T03:44:38Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/15
depends_on: [001, 002]
parallel: true
conflicts_with: []
---

# Task: Error Handling & Health Checks

## Description
Implement comprehensive error handling, retry logic, and health monitoring across the AI system. Ensure graceful degradation and clear error messages for users.

## Acceptance Criteria
- [ ] All async operations have try/catch blocks
- [ ] Retry logic for transient failures (network, model loading)
- [ ] Health check system monitors provider availability
- [ ] Error messages are user-friendly
- [ ] Errors logged appropriately (dev vs prod)
- [ ] Graceful fallbacks when AI unavailable
- [ ] Error boundary for React components

## Technical Details

### Files to Create
```
src/lib/ai/
├── error-handler.ts         # Centralized error handling
└── health-monitor.ts        # Health check system

src/components/ai/
└── AIErrorBoundary.tsx      # React error boundary
```

### Implementation

1. **Error Types** (`src/lib/ai/error-handler.ts`)
```typescript
export class AIError extends Error {
  constructor(
    message: string,
    public code: string,
    public recoverable: boolean = false,
    public cause?: Error
  ) {
    super(message);
    this.name = 'AIError';
  }
}

export class ProviderUnavailableError extends AIError {
  constructor(providerName: string, cause?: Error) {
    super(
      `AI provider "${providerName}" is not available`,
      'PROVIDER_UNAVAILABLE',
      true,
      cause
    );
  }
}

export class ModelLoadError extends AIError {
  constructor(modelName: string, cause?: Error) {
    super(
      `Failed to load model "${modelName}"`,
      'MODEL_LOAD_FAILED',
      true,
      cause
    );
  }
}

export class EmbeddingError extends AIError {
  constructor(message: string, cause?: Error) {
    super(
      `Embedding generation failed: ${message}`,
      'EMBEDDING_FAILED',
      true,
      cause
    );
  }
}

export class NetworkError extends AIError {
  constructor(message: string, cause?: Error) {
    super(
      `Network error: ${message}`,
      'NETWORK_ERROR',
      true,
      cause
    );
  }
}
```

2. **Retry Logic** (`src/lib/ai/error-handler.ts`)
```typescript
export interface RetryOptions {
  maxAttempts?: number;
  delayMs?: number;
  backoffMultiplier?: number;
  shouldRetry?: (error: Error) => boolean;
}

export async function withRetry<T>(
  fn: () => Promise<T>,
  options: RetryOptions = {}
): Promise<T> {
  const {
    maxAttempts = 3,
    delayMs = 1000,
    backoffMultiplier = 2,
    shouldRetry = (error) => {
      // Retry on network errors, model loading errors
      return error instanceof NetworkError ||
             error instanceof ModelLoadError;
    },
  } = options;

  let lastError: Error;
  let delay = delayMs;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      if (attempt === maxAttempts || !shouldRetry(lastError)) {
        throw lastError;
      }

      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= backoffMultiplier;
    }
  }

  throw lastError!;
}
```

3. **Error Handler** (`src/lib/ai/error-handler.ts`)
```typescript
export class AIErrorHandler {
  private static instance: AIErrorHandler;

  private constructor() {}

  static getInstance(): AIErrorHandler {
    if (!this.instance) {
      this.instance = new AIErrorHandler();
    }
    return this.instance;
  }

  handle(error: Error, context?: string): AIError {
    // Log error (dev mode only)
    if (import.meta.env.DEV) {
      console.error(`[AI Error${context ? ` - ${context}` : ''}]:`, error);
    }

    // Convert to AIError if not already
    if (error instanceof AIError) {
      return error;
    }

    // Categorize error
    if (error.message.includes('Chrome AI not available')) {
      return new ProviderUnavailableError('Chrome AI', error);
    }

    if (error.message.includes('network') || error.message.includes('fetch')) {
      return new NetworkError(error.message, error);
    }

    if (error.message.includes('model') || error.message.includes('load')) {
      return new ModelLoadError('unknown', error);
    }

    // Generic AI error
    return new AIError(
      error.message || 'Unknown AI error',
      'UNKNOWN',
      false,
      error
    );
  }

  getUserMessage(error: AIError): string {
    switch (error.code) {
      case 'PROVIDER_UNAVAILABLE':
        return 'AI is currently unavailable. Please check that you are using Chrome Canary/Dev with the Prompt API enabled.';

      case 'MODEL_LOAD_FAILED':
        return 'Failed to download AI models. Please check your internet connection and try again.';

      case 'EMBEDDING_FAILED':
        return 'Could not process your text. Please try again.';

      case 'NETWORK_ERROR':
        return 'Network connection issue. Please check your internet connection.';

      default:
        return 'An unexpected error occurred. Please try again.';
    }
  }

  getSupportInfo(error: AIError): string {
    return `Error Code: ${error.code}\nRecoverable: ${error.recoverable}\n\nFor support: https://github.com/yourusername/lumara/issues`;
  }
}

export const errorHandler = AIErrorHandler.getInstance();
```

4. **Health Monitor** (`src/lib/ai/health-monitor.ts`)
```typescript
import { AIProvider } from './types';

export interface HealthStatus {
  provider: string | null;
  status: 'healthy' | 'degraded' | 'unavailable';
  lastCheck: Date;
  consecutiveFailures: number;
  uptime: number; // percentage
}

export class HealthMonitor {
  private status: HealthStatus = {
    provider: null,
    status: 'unavailable',
    lastCheck: new Date(),
    consecutiveFailures: 0,
    uptime: 100,
  };

  private checkInterval: number | null = null;
  private checks: { success: boolean; timestamp: Date }[] = [];

  startMonitoring(provider: AIProvider, intervalMs = 60000): void {
    this.status.provider = provider.name;

    // Initial check
    this.performCheck(provider);

    // Periodic checks
    this.checkInterval = window.setInterval(() => {
      this.performCheck(provider);
    }, intervalMs);
  }

  stopMonitoring(): void {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }

  private async performCheck(provider: AIProvider): Promise<void> {
    try {
      const health = await provider.healthCheck();

      this.checks.push({
        success: health.available,
        timestamp: new Date(),
      });

      // Keep last 100 checks
      if (this.checks.length > 100) {
        this.checks.shift();
      }

      if (health.available) {
        this.status.status = 'healthy';
        this.status.consecutiveFailures = 0;
      } else {
        this.status.consecutiveFailures++;
        this.status.status = this.status.consecutiveFailures > 3
          ? 'unavailable'
          : 'degraded';
      }
    } catch (error) {
      this.checks.push({
        success: false,
        timestamp: new Date(),
      });

      this.status.consecutiveFailures++;
      this.status.status = 'unavailable';
    }

    this.status.lastCheck = new Date();
    this.status.uptime = this.calculateUptime();
  }

  private calculateUptime(): number {
    if (this.checks.length === 0) return 100;

    const successCount = this.checks.filter(c => c.success).length;
    return (successCount / this.checks.length) * 100;
  }

  getStatus(): HealthStatus {
    return { ...this.status };
  }
}

export const healthMonitor = new HealthMonitor();
```

5. **React Error Boundary** (`src/components/ai/AIErrorBoundary.tsx`)
```typescript
import { Component, ReactNode } from 'react';
import { AIError } from '@/lib/ai/error-handler';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: AIError | null;
}

export class AIErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error: error instanceof AIError ? error : null,
    };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    if (import.meta.env.DEV) {
      console.error('AI Error Boundary caught:', error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="ai-error-boundary">
          <h3>AI System Error</h3>
          {this.state.error && (
            <p>{this.state.error.message}</p>
          )}
          <button onClick={() => this.setState({ hasError: false, error: null })}>
            Try Again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Usage Examples
```typescript
// With retry
const embedding = await withRetry(
  () => generateEmbedding(text),
  { maxAttempts: 3, delayMs: 1000 }
);

// With error handling
try {
  await provider.chat(message);
} catch (error) {
  const aiError = errorHandler.handle(error, 'chat');
  showUserMessage(errorHandler.getUserMessage(aiError));

  if (aiError.recoverable) {
    // Offer retry
  }
}

// Health monitoring
healthMonitor.startMonitoring(provider);
const status = healthMonitor.getStatus();
if (status.status === 'degraded') {
  showWarning('AI system is experiencing issues');
}
```

## Dependencies
- [ ] Tasks 001-002 for error sources
- [ ] React Error Boundary support (React 16.8+)

## Effort Estimate
- **Size:** M (Medium)
- **Hours:** 8-12 hours
- **Parallel:** Yes - Independent

## Definition of Done
- [ ] All error types defined
- [ ] Retry logic implemented
- [ ] Health monitoring working
- [ ] Error boundary functional
- [ ] User-friendly error messages
- [ ] Logging appropriate
- [ ] Unit tests for error handling
- [ ] Documentation complete

---
name: Write Project Documentation
status: open
created: 2025-10-13T19:38:52Z
updated: 2025-10-13T19:44:05Z
github: https://github.com/tgarrochinho/lumara-frontend/issues/12
depends_on: [8, 10]
parallel: true
conflicts_with: []
---

# Task: Write Project Documentation

## Description
Create comprehensive documentation for the Lumara project including setup instructions, architecture overview, development guidelines, and code comments in configuration files. This documentation will serve as the primary reference for developers working on the project.

## Acceptance Criteria
- [ ] README.md written with setup instructions, npm scripts, and quick start guide
- [ ] DEVELOPMENT.md written with architecture overview and development guidelines
- [ ] Zustand usage patterns documented
- [ ] TanStack Query usage patterns documented
- [ ] Dexie usage patterns documented
- [ ] Component patterns documented
- [ ] Project structure explained
- [ ] All config files have explanatory comments
- [ ] Documentation is clear, accurate, and actionable

## Technical Details

**README.md Structure:**
```markdown
# Lumara - Your Metacognitive AI Partner

Lumara is a metacognitive AI partner designed to help you think more clearly through personalized memory management and reflective interactions.

## Features
- Local-first architecture with offline support
- Real-time memory management with Dexie (IndexedDB)
- Modern UI with Tailwind CSS and smooth animations
- TypeScript for type safety
- Fast development with Vite HMR

## Prerequisites
- Node.js 18+
- npm 9+

## Quick Start

### Installation
```bash
npm install
```

### Development
```bash
npm run dev
```
Open http://localhost:5173

### Build
```bash
npm run build
```

### Preview Production Build
```bash
npm run preview
```

## Available Scripts
- `npm run dev` - Start development server with HMR
- `npm run build` - Build for production
- `npm run preview` - Preview production build locally
- `npm run type-check` - Run TypeScript type checking
- `npm run lint` - Run ESLint
- `npm run format` - Format code with Prettier

## Project Structure
```
lumara-frontend/
├── src/
│   ├── components/     # React components
│   │   └── ui/         # Base UI components
│   ├── store/          # Zustand state management
│   ├── db/             # Dexie database schema
│   ├── hooks/          # Custom React hooks
│   ├── utils/          # Utility functions
│   └── styles/         # Global styles
├── .claude/            # Claude Code configuration
├── docs/               # Project documentation
└── planning/           # Product specifications
```

## Technology Stack
- **Frontend**: React 18, TypeScript
- **Build Tool**: Vite
- **Styling**: Tailwind CSS
- **State Management**: Zustand
- **Server State**: TanStack Query
- **Database**: Dexie (IndexedDB)
- **Animations**: Framer Motion, GSAP

## Learn More
See [DEVELOPMENT.md](./DEVELOPMENT.md) for detailed development guidelines.
```

**DEVELOPMENT.md Structure:**
```markdown
# Development Guide

## Architecture Overview

Lumara follows a local-first architecture pattern:

### Data Flow
1. **UI Layer** (React components) → User interactions
2. **State Layer** (Zustand) → Application state
3. **Query Layer** (TanStack Query) → Server state caching
4. **Database Layer** (Dexie) → Local persistence

### Key Principles
- **Offline-first**: All data stored locally in IndexedDB
- **Optimistic updates**: UI updates immediately, sync later
- **Type safety**: Full TypeScript coverage
- **Component composition**: Small, reusable components

## State Management with Zustand

### When to Use Zustand
- Global UI state (theme, sidebar open/closed)
- User preferences
- Application-wide settings
- Cross-component communication

### Example Store
```typescript
import { create } from 'zustand'

interface AppState {
  sidebarOpen: boolean
  toggleSidebar: () => void
}

export const useAppStore = create<AppState>((set) => ({
  sidebarOpen: true,
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
}))
```

### Usage in Components
```typescript
function Sidebar() {
  const { sidebarOpen, toggleSidebar } = useAppStore()

  return (
    <div className={cn('sidebar', sidebarOpen && 'open')}>
      <button onClick={toggleSidebar}>Toggle</button>
    </div>
  )
}
```

## Server State with TanStack Query

### When to Use TanStack Query
- Fetching data from APIs
- Caching API responses
- Background refetching
- Mutations with optimistic updates

### Example Query
```typescript
import { useQuery } from '@tanstack/react-query'

function useMemories() {
  return useQuery({
    queryKey: ['memories'],
    queryFn: async () => {
      const memories = await db.memories.toArray()
      return memories
    },
  })
}
```

### Example Mutation
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'

function useCreateMemory() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (memory: NewMemory) => {
      return await db.memories.add(memory)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['memories'] })
    },
  })
}
```

## Database with Dexie

### Schema Definition
```typescript
import Dexie, { Table } from 'dexie'

export interface Memory {
  id?: number
  content: string
  createdAt: Date
  tags: string[]
}

export class LumaraDB extends Dexie {
  memories!: Table<Memory>

  constructor() {
    super('LumaraDB')
    this.version(1).stores({
      memories: '++id, createdAt, *tags',
    })
  }
}

export const db = new LumaraDB()
```

### CRUD Operations
```typescript
// Create
await db.memories.add({ content: 'Hello', createdAt: new Date(), tags: [] })

// Read
const memories = await db.memories.toArray()
const memory = await db.memories.get(1)

// Update
await db.memories.update(1, { content: 'Updated' })

// Delete
await db.memories.delete(1)

// Query with where
const tagged = await db.memories.where('tags').equals('important').toArray()
```

## Component Patterns

### Base Component Pattern
All UI components follow this structure:

```typescript
import { forwardRef, HTMLAttributes } from 'react'
import { cn } from '@/utils/cn'

interface ComponentProps extends HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'primary'
}

export const Component = forwardRef<HTMLDivElement, ComponentProps>(
  ({ className, variant = 'default', ...props }, ref) => {
    return (
      <div
        ref={ref}
        className={cn('base-classes', variantClasses[variant], className)}
        {...props}
      />
    )
  }
)

Component.displayName = 'Component'
```

### Benefits
- Proper TypeScript typing
- Ref forwarding for parent access
- className merging with cn()
- Spread props for flexibility

## Project Structure Explained

```
src/
├── components/
│   ├── ui/              # Base UI components (Button, Card, Input)
│   ├── features/        # Feature-specific components
│   └── layouts/         # Layout components
├── store/
│   ├── appStore.ts      # Global app state
│   └── userStore.ts     # User preferences
├── db/
│   └── schema.ts        # Dexie database schema
├── hooks/
│   ├── useMemories.ts   # TanStack Query hooks
│   └── useLocalStorage.ts
├── utils/
│   ├── cn.ts            # className utility
│   └── date.ts          # Date formatting
└── styles/
    └── globals.css      # Global Tailwind styles
```

## Development Workflow

### Adding a New Feature
1. Create component in `src/components/features/`
2. Add state if needed in `src/store/`
3. Create TanStack Query hooks in `src/hooks/`
4. Update database schema if needed in `src/db/`
5. Test in browser with HMR
6. Commit when working

### Styling Guidelines
- Use Tailwind utility classes
- Follow mobile-first responsive design
- Use design tokens (brand-indigo, brand-violet)
- Maintain dark mode as default
- Use cn() for conditional classes

### Type Safety
- Never use `any` type
- Define interfaces for all props
- Use TypeScript strict mode
- Type all database operations

## Testing
- Manual testing with dev server
- Verify HMR works
- Check browser console for errors
- Test offline functionality
- Verify animations perform well

## Common Patterns

### Loading States
```typescript
function Component() {
  const { data, isLoading, error } = useMemories()

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return <div>{/* render data */}</div>
}
```

### Form Handling
```typescript
function Form() {
  const [value, setValue] = useState('')
  const createMutation = useCreateMemory()

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    createMutation.mutate({ content: value, createdAt: new Date(), tags: [] })
  }

  return (
    <form onSubmit={handleSubmit}>
      <Input value={value} onChange={(e) => setValue(e.target.value)} />
      <Button type="submit">Create</Button>
    </form>
  )
}
```

## Troubleshooting

### HMR Not Working
- Check Vite server is running
- Verify file is in src/
- Restart dev server

### TypeScript Errors
- Run `npm run type-check`
- Check interface definitions
- Verify imports are correct

### Database Errors
- Check Dexie schema version
- Verify IndexedDB not corrupted
- Clear browser storage if needed

## Resources
- [Vite Documentation](https://vitejs.dev/)
- [React Documentation](https://react.dev/)
- [Tailwind CSS](https://tailwindcss.com/)
- [Zustand](https://github.com/pmndrs/zustand)
- [TanStack Query](https://tanstack.com/query/)
- [Dexie.js](https://dexie.org/)
```

**Add Comments to Config Files:**
Add explanatory comments to:
- `vite.config.ts`
- `tailwind.config.js`
- `tsconfig.json`
- `package.json` (scripts section)

## Dependencies
- [ ] Task 006 (Database and data fetching setup) must be completed
- [ ] Task 008 (Base UI components) must be completed
- [ ] All configuration files finalized
- [ ] Project structure established

## Effort Estimate
- Size: M
- Hours: 4 hours
- Parallel: true (can be written alongside other tasks)

## Definition of Done
- [ ] README.md created and complete
- [ ] DEVELOPMENT.md created and complete
- [ ] All usage patterns documented with examples
- [ ] Config files have explanatory comments
- [ ] Documentation reviewed for accuracy
- [ ] No broken links or incorrect information
- [ ] Code examples are syntactically correct
- [ ] Documentation follows consistent formatting
